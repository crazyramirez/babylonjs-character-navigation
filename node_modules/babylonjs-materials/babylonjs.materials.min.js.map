{"version":3,"file":"babylonjs.materials.min.js","mappings":"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","sources":["webpack://MATERIALS/webpack/universalModuleDefinition","webpack://MATERIALS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://MATERIALS/webpack/bootstrap","webpack://MATERIALS/webpack/runtime/define property getters","webpack://MATERIALS/webpack/runtime/global","webpack://MATERIALS/webpack/runtime/hasOwnProperty shorthand","webpack://MATERIALS/webpack/runtime/make namespace object","webpack://MATERIALS/../../../../node_modules/tslib/tslib.es6.js","webpack://MATERIALS/../../../lts/materials/generated/cell/cell.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/cell/cell.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/cell/cellMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/custom/customMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/custom/pbrCustomMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/fire/fire.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/fire/fire.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/fire/fireMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/fur/fur.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/fur/fur.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/fur/furMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/gradient/gradient.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/gradient/gradient.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/gradient/gradientMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/grid/grid.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/grid/grid.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/grid/gridMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/lava/lava.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/lava/lava.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/lava/lavaMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/mix/mix.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/mix/mix.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/mix/mixMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/normal/normal.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/normal/normal.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/normal/normalMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/shadowOnly/shadowOnly.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/shadowOnly/shadowOnly.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/shadowOnly/shadowOnlyMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/simple/simple.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/simple/simple.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/simple/simpleMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/sky/sky.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/sky/sky.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/sky/skyMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/terrain/terrain.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/terrain/terrain.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/terrain/terrainMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/triPlanar/triplanar.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/triPlanar/triplanar.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/triPlanar/triPlanarMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/water/water.fragment.ts","webpack://MATERIALS/../../../lts/materials/generated/water/water.vertex.ts","webpack://MATERIALS/../../../lts/materials/generated/water/waterMaterial.ts","webpack://MATERIALS/../../../lts/materials/generated/legacy/legacy.ts","webpack://MATERIALS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-materials\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-materials\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"MATERIALS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__520__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__520__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"cellPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\rvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform sampler2D diffuseSampler;\runiform vec2 vDiffuseInfos;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\nvec3 computeCustomDiffuseLighting(lightingInfo info,vec3 diffuseBase,float shadow)\r{\rdiffuseBase=info.diffuse*shadow;\r#ifdef CELLBASIC\nfloat level=1.0;\rif (info.ndl<0.5)\rlevel=0.5;\rdiffuseBase.rgb*vec3(level,level,level);\r#else\nfloat ToonThresholds[4];\rToonThresholds[0]=0.95;\rToonThresholds[1]=0.5;\rToonThresholds[2]=0.2;\rToonThresholds[3]=0.03;\rfloat ToonBrightnessLevels[5];\rToonBrightnessLevels[0]=1.0;\rToonBrightnessLevels[1]=0.8;\rToonBrightnessLevels[2]=0.6;\rToonBrightnessLevels[3]=0.35;\rToonBrightnessLevels[4]=0.2;\rif (info.ndl>ToonThresholds[0])\r{\rdiffuseBase.rgb*=ToonBrightnessLevels[0];\r}\relse if (info.ndl>ToonThresholds[1])\r{\rdiffuseBase.rgb*=ToonBrightnessLevels[1];\r}\relse if (info.ndl>ToonThresholds[2])\r{\rdiffuseBase.rgb*=ToonBrightnessLevels[2];\r}\relse if (info.ndl>ToonThresholds[3])\r{\rdiffuseBase.rgb*=ToonBrightnessLevels[3];\r}\relse\r{\rdiffuseBase.rgb*=ToonBrightnessLevels[4];\r}\r#endif\nreturn max(diffuseBase,vec3(0.2));\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\r#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\nlightingInfo info;\rvec3 diffuseBase=vec3(0.,0.,0.);\rfloat shadow=1.;\rfloat glossiness=0.;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\rvec4 color=vec4(finalDiffuse,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const cellPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"cellVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform mat4 diffuseMatrix;\runiform vec2 vDiffuseInfos;\r#endif\n#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const cellVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./cell.fragment\";\r\nimport \"./cell.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass CellMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public NDOTL = true;\r\n    public CUSTOMUSERLIGHTING = true;\r\n    public CELLBASIC = true;\r\n    public DEPTHPREPASS = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class CellMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"computeHighLevel\")\r\n    public _computeHighLevel: boolean = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public computeHighLevel: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new CellMaterialDefines();\r\n        }\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        defines.CELLBASIC = !this.computeHighLevel;\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"cell\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <CellMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        return this._diffuseTexture === texture;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"CellMaterial\";\r\n    }\r\n\r\n    public clone(name: string): CellMaterial {\r\n        return SerializationHelper.Clone<CellMaterial>(() => new CellMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.CellMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): CellMaterial {\r\n        return SerializationHelper.Parse(() => new CellMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CellMaterial\", CellMaterial);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nexport class CustomShaderStructure {\r\n    public FragmentStore: string;\r\n    public VertexStore: string;\r\n\r\n    constructor() {}\r\n}\r\n\r\nexport class ShaderSpecialParts {\r\n    constructor() {}\r\n\r\n    public Fragment_Begin: string;\r\n    public Fragment_Definitions: string;\r\n    public Fragment_MainBegin: string;\r\n    public Fragment_MainEnd: string;\r\n\r\n    // diffuseColor\r\n    public Fragment_Custom_Diffuse: string;\r\n    // lights\r\n    public Fragment_Before_Lights: string;\r\n    // fog\r\n    public Fragment_Before_Fog: string;\r\n    // alpha\r\n    public Fragment_Custom_Alpha: string;\r\n\r\n    public Fragment_Before_FragColor: string;\r\n\r\n    public Vertex_Begin: string;\r\n    public Vertex_Definitions: string;\r\n    public Vertex_MainBegin: string;\r\n\r\n    // positionUpdated\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    // normalUpdated\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    // worldPosComputed\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    // mainEnd\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\nexport class CustomMaterial extends StandardMaterial {\r\n    public static ShaderIndexer = 1;\r\n    public CustomParts: ShaderSpecialParts;\r\n    _isCreatedShader: boolean;\r\n    _createdShaderName: string;\r\n    _customUniform: string[];\r\n    _newUniforms: string[];\r\n    _newUniformInstances: { [name: string]: any };\r\n    _newSamplerInstances: { [name: string]: Texture };\r\n    _customAttributes: string[];\r\n\r\n    public FragmentShader: string;\r\n    public VertexShader: string;\r\n\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec4\") {\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    public Builder(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: MaterialDefines | string[], attributes?: string[]): string {\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        if (this._isCreatedShader) {\r\n            return this._createdShaderName;\r\n        }\r\n        this._isCreatedShader = false;\r\n\r\n        CustomMaterial.ShaderIndexer++;\r\n        const name: string = \"custom_\" + CustomMaterial.ShaderIndexer;\r\n\r\n        const fn_afterBind = this._afterBind.bind(this);\r\n        this._afterBind = (m, e) => {\r\n            if (!e) {\r\n                return;\r\n            }\r\n            this.AttachAfterBind(m, e);\r\n            try {\r\n                fn_afterBind(m, e);\r\n            } catch (e) {}\r\n        };\r\n\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this.VertexShader.replace(\"#define CUSTOM_VERTEX_BEGIN\", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_VERTEX_DEFINITIONS\",\r\n                (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : \"\")\r\n            )\r\n            .replace(\"#define CUSTOM_VERTEX_MAIN_BEGIN\", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_POSITION\", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_NORMAL\", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_MAIN_END\", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : \"\");\r\n\r\n        if (this.CustomParts.Vertex_After_WorldPosComputed) {\r\n            Effect.ShadersStore[name + \"VertexShader\"] = Effect.ShadersStore[name + \"VertexShader\"].replace(\r\n                \"#define CUSTOM_VERTEX_UPDATE_WORLDPOS\",\r\n                this.CustomParts.Vertex_After_WorldPosComputed\r\n            );\r\n        }\r\n\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this.FragmentShader.replace(\r\n            \"#define CUSTOM_FRAGMENT_BEGIN\",\r\n            this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : \"\"\r\n        )\r\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_BEGIN\", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_FRAGMENT_DEFINITIONS\",\r\n                (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : \"\")\r\n            )\r\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_ALPHA\", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_END\", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : \"\");\r\n\r\n        if (this.CustomParts.Fragment_Before_Fog) {\r\n            Effect.ShadersStore[name + \"PixelShader\"] = Effect.ShadersStore[name + \"PixelShader\"].replace(\r\n                \"#define CUSTOM_FRAGMENT_BEFORE_FOG\",\r\n                this.CustomParts.Fragment_Before_Fog\r\n            );\r\n        }\r\n\r\n        this._isCreatedShader = true;\r\n        this._createdShaderName = name;\r\n\r\n        return name;\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.CustomParts = new ShaderSpecialParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"defaultPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"defaultVertexShader\"];\r\n    }\r\n\r\n    public AddUniform(name: string, kind: string, param: any): CustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = new Array();\r\n            this._newUniforms = new Array();\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    public AddAttribute(name: string): CustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_Diffuse(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace(\"result\", \"diffuseColor\");\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_Alpha(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_Lights(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_Fog(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_FragColor(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Begin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Definitions(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_MainBegin(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_MainEnd(shaderPart: string): CustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CustomMaterial\", CustomMaterial);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport type { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { ShaderCodeInliner } from \"core/Engines/Processors/shaderCodeInliner\";\r\nimport type { ICustomShaderNameResolveOptions } from \"core/Materials/material\";\r\n\r\nexport class ShaderAlebdoParts {\r\n    constructor() {}\r\n\r\n    public Fragment_Begin: string;\r\n    public Fragment_Definitions: string;\r\n    public Fragment_MainBegin: string;\r\n    public Fragment_MainEnd: string;\r\n\r\n    // albedoColor\r\n    public Fragment_Custom_Albedo: string;\r\n    // lights\r\n    public Fragment_Before_Lights: string;\r\n    // roughness\r\n    public Fragment_Custom_MetallicRoughness: string;\r\n    // microsurface\r\n    public Fragment_Custom_MicroSurface: string;\r\n    // fog\r\n    public Fragment_Before_Fog: string;\r\n    // alpha\r\n    public Fragment_Custom_Alpha: string;\r\n    // color composition\r\n    public Fragment_Before_FinalColorComposition: string;\r\n    // frag color\r\n    public Fragment_Before_FragColor: string;\r\n\r\n    public Vertex_Begin: string;\r\n    public Vertex_Definitions: string;\r\n    public Vertex_MainBegin: string;\r\n\r\n    // positionUpdated\r\n    public Vertex_Before_PositionUpdated: string;\r\n\r\n    // normalUpdated\r\n    public Vertex_Before_NormalUpdated: string;\r\n\r\n    // worldPosComputed\r\n    public Vertex_After_WorldPosComputed: string;\r\n\r\n    // mainEnd\r\n    public Vertex_MainEnd: string;\r\n}\r\n\r\nexport class PBRCustomMaterial extends PBRMaterial {\r\n    public static ShaderIndexer = 1;\r\n    public CustomParts: ShaderAlebdoParts;\r\n    _isCreatedShader: boolean;\r\n    _createdShaderName: string;\r\n    _customUniform: string[];\r\n    _newUniforms: string[];\r\n    _newUniformInstances: { [name: string]: any };\r\n    _newSamplerInstances: { [name: string]: Texture };\r\n    _customAttributes: string[];\r\n\r\n    public FragmentShader: string;\r\n    public VertexShader: string;\r\n\r\n    public AttachAfterBind(mesh: Mesh | undefined, effect: Effect) {\r\n        if (this._newUniformInstances) {\r\n            for (const el in this._newUniformInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"vec2\") {\r\n                    effect.setVector2(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec3\") {\r\n                    effect.setVector3(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"vec4\") {\r\n                    effect.setVector4(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"mat4\") {\r\n                    effect.setMatrix(ea[1], this._newUniformInstances[el]);\r\n                } else if (ea[0] == \"float\") {\r\n                    effect.setFloat(ea[1], this._newUniformInstances[el]);\r\n                }\r\n            }\r\n        }\r\n        if (this._newSamplerInstances) {\r\n            for (const el in this._newSamplerInstances) {\r\n                const ea = el.toString().split(\"-\");\r\n                if (ea[0] == \"sampler2D\" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {\r\n                    effect.setTexture(ea[1], this._newSamplerInstances[el]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public ReviewUniform(name: string, arr: string[]): string[] {\r\n        if (name == \"uniform\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") == -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        if (name == \"sampler\" && this._newUniforms) {\r\n            for (let ind = 0; ind < this._newUniforms.length; ind++) {\r\n                if (this._customUniform[ind].indexOf(\"sampler\") != -1) {\r\n                    arr.push(this._newUniforms[ind].replace(/\\[\\d*\\]/g, \"\"));\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    public Builder(\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ): string {\r\n        if (options) {\r\n            const currentProcessing = options.processFinalCode;\r\n            options.processFinalCode = (type: string, code: string) => {\r\n                if (type === \"vertex\") {\r\n                    return currentProcessing ? currentProcessing(type, code) : code;\r\n                }\r\n                const sci = new ShaderCodeInliner(code);\r\n                sci.inlineToken = \"#define pbr_inline\";\r\n                sci.processCode();\r\n                return currentProcessing ? currentProcessing(type, sci.code) : sci.code;\r\n            };\r\n        }\r\n\r\n        if (attributes && this._customAttributes && this._customAttributes.length > 0) {\r\n            attributes.push(...this._customAttributes);\r\n        }\r\n\r\n        this.ReviewUniform(\"uniform\", uniforms);\r\n        this.ReviewUniform(\"sampler\", samplers);\r\n\r\n        if (this._isCreatedShader) {\r\n            return this._createdShaderName;\r\n        }\r\n        this._isCreatedShader = false;\r\n\r\n        PBRCustomMaterial.ShaderIndexer++;\r\n        const name: string = \"custom_\" + PBRCustomMaterial.ShaderIndexer;\r\n\r\n        const fn_afterBind = this._afterBind.bind(this);\r\n        this._afterBind = (m, e) => {\r\n            if (!e) {\r\n                return;\r\n            }\r\n            this.AttachAfterBind(m, e);\r\n            try {\r\n                fn_afterBind(m, e);\r\n            } catch (e) {}\r\n        };\r\n\r\n        Effect.ShadersStore[name + \"VertexShader\"] = this.VertexShader.replace(\"#define CUSTOM_VERTEX_BEGIN\", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_VERTEX_DEFINITIONS\",\r\n                (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : \"\")\r\n            )\r\n            .replace(\"#define CUSTOM_VERTEX_MAIN_BEGIN\", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_POSITION\", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_UPDATE_NORMAL\", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : \"\")\r\n            .replace(\"#define CUSTOM_VERTEX_MAIN_END\", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : \"\");\r\n\r\n        if (this.CustomParts.Vertex_After_WorldPosComputed) {\r\n            Effect.ShadersStore[name + \"VertexShader\"] = Effect.ShadersStore[name + \"VertexShader\"].replace(\r\n                \"#define CUSTOM_VERTEX_UPDATE_WORLDPOS\",\r\n                this.CustomParts.Vertex_After_WorldPosComputed\r\n            );\r\n        }\r\n\r\n        Effect.ShadersStore[name + \"PixelShader\"] = this.FragmentShader.replace(\r\n            \"#define CUSTOM_FRAGMENT_BEGIN\",\r\n            this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : \"\"\r\n        )\r\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_BEGIN\", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_FRAGMENT_DEFINITIONS\",\r\n                (this._customUniform ? this._customUniform.join(\"\\n\") : \"\") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : \"\")\r\n            )\r\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_ALBEDO\", this.CustomParts.Fragment_Custom_Albedo ? this.CustomParts.Fragment_Custom_Albedo : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_ALPHA\", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS\",\r\n                this.CustomParts.Fragment_Custom_MetallicRoughness ? this.CustomParts.Fragment_Custom_MetallicRoughness : \"\"\r\n            )\r\n            .replace(\"#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE\", this.CustomParts.Fragment_Custom_MicroSurface ? this.CustomParts.Fragment_Custom_MicroSurface : \"\")\r\n            .replace(\r\n                \"#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\",\r\n                this.CustomParts.Fragment_Before_FinalColorComposition ? this.CustomParts.Fragment_Before_FinalColorComposition : \"\"\r\n            )\r\n            .replace(\"#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : \"\")\r\n            .replace(\"#define CUSTOM_FRAGMENT_MAIN_END\", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : \"\");\r\n\r\n        if (this.CustomParts.Fragment_Before_Fog) {\r\n            Effect.ShadersStore[name + \"PixelShader\"] = Effect.ShadersStore[name + \"PixelShader\"].replace(\r\n                \"#define CUSTOM_FRAGMENT_BEFORE_FOG\",\r\n                this.CustomParts.Fragment_Before_Fog\r\n            );\r\n        }\r\n\r\n        this._isCreatedShader = true;\r\n        this._createdShaderName = name;\r\n\r\n        return name;\r\n    }\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.CustomParts = new ShaderAlebdoParts();\r\n        this.customShaderNameResolve = this.Builder;\r\n\r\n        this.FragmentShader = Effect.ShadersStore[\"pbrPixelShader\"];\r\n        this.VertexShader = Effect.ShadersStore[\"pbrVertexShader\"];\r\n\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockAlbedoOpacity>/g, Effect.IncludesShadersStore[\"pbrBlockAlbedoOpacity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockReflectivity>/g, Effect.IncludesShadersStore[\"pbrBlockReflectivity\"]);\r\n        this.FragmentShader = this.FragmentShader.replace(/#include<pbrBlockFinalColorComposition>/g, Effect.IncludesShadersStore[\"pbrBlockFinalColorComposition\"]);\r\n    }\r\n\r\n    public AddUniform(name: string, kind: string, param: any): PBRCustomMaterial {\r\n        if (!this._customUniform) {\r\n            this._customUniform = new Array();\r\n            this._newUniforms = new Array();\r\n            this._newSamplerInstances = {};\r\n            this._newUniformInstances = {};\r\n        }\r\n        if (param) {\r\n            if (kind.indexOf(\"sampler\") != -1) {\r\n                (<any>this._newSamplerInstances)[kind + \"-\" + name] = param;\r\n            } else {\r\n                (<any>this._newUniformInstances)[kind + \"-\" + name] = param;\r\n            }\r\n        }\r\n        this._customUniform.push(\"uniform \" + kind + \" \" + name + \";\");\r\n        this._newUniforms.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    public AddAttribute(name: string): PBRCustomMaterial {\r\n        if (!this._customAttributes) {\r\n            this._customAttributes = [];\r\n        }\r\n\r\n        this._customAttributes.push(name);\r\n\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_Albedo(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Albedo = shaderPart.replace(\"result\", \"surfaceAlbedo\");\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_Alpha(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace(\"result\", \"alpha\");\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_Lights(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Lights = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_MetallicRoughness(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MetallicRoughness = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Custom_MicroSurface(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Custom_MicroSurface = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_Fog(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_Fog = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_FinalColorComposition(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FinalColorComposition = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Fragment_Before_FragColor(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_Before_FragColor = shaderPart.replace(\"result\", \"color\");\r\n        return this;\r\n    }\r\n\r\n    public Fragment_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Fragment_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Begin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Begin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Definitions(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Definitions = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_MainBegin(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainBegin = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Before_PositionUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace(\"result\", \"positionUpdated\");\r\n        return this;\r\n    }\r\n\r\n    public Vertex_Before_NormalUpdated(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace(\"result\", \"normalUpdated\");\r\n        return this;\r\n    }\r\n\r\n    public Vertex_After_WorldPosComputed(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;\r\n        return this;\r\n    }\r\n\r\n    public Vertex_MainEnd(shaderPart: string): PBRCustomMaterial {\r\n        this.CustomParts.Vertex_MainEnd = shaderPart;\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PBRCustomMaterial\", PBRCustomMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"firePixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;varying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\nuniform sampler2D distortionSampler;uniform sampler2D opacitySampler;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\nvec4 bx2(vec4 x)\n{return vec4(2.0)*x-vec4(1.0);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);float alpha=1.0;\n#ifdef DIFFUSE\nconst float distortionAmount0 =0.092;const float distortionAmount1 =0.092;const float distortionAmount2 =0.092;vec2 heightAttenuation=vec2(0.3,0.39);vec4 noise0=texture2D(distortionSampler,vDistortionCoords1);vec4 noise1=texture2D(distortionSampler,vDistortionCoords2);vec4 noise2=texture2D(distortionSampler,vDistortionCoords3);vec4 noiseSum=bx2(noise0)*distortionAmount0+bx2(noise1)*distortionAmount1+bx2(noise2)*distortionAmount2;vec4 perturbedBaseCoords=vec4(vDiffuseUV,0.0,1.0)+noiseSum*(vDiffuseUV.y*heightAttenuation.x+heightAttenuation.y);vec4 opacityColor=texture2D(opacitySampler,perturbedBaseCoords.xy);\n#ifdef ALPHATEST\nif (opacityColor.r<0.1)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor=texture2D(diffuseSampler,perturbedBaseCoords.xy)*2.0;baseColor*=opacityColor;baseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\nvec3 diffuseBase=vec3(1.0,1.0,1.0);\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec4 color=vec4(baseColor.rgb,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const firePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"fireVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\nuniform float time;uniform float speed;\n#ifdef DIFFUSE\nvarying vec2 vDistortionCoords1;varying vec2 vDistortionCoords2;varying vec2 vDistortionCoords3;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef DIFFUSE\nvDiffuseUV=uv;vDiffuseUV.y-=0.2;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#ifdef DIFFUSE\nvec3 layerSpeed=vec3(-0.2,-0.52,-0.1)*speed;vDistortionCoords1.x=uv.x;vDistortionCoords1.y=uv.y+layerSpeed.x*time/1000.0;vDistortionCoords2.x=uv.x;vDistortionCoords2.y=uv.y+layerSpeed.y*time/1000.0;vDistortionCoords3.x=uv.x;vDistortionCoords3.y=uv.y+layerSpeed.z*time/1000.0;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const fireVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\nimport \"./fire.fragment\";\r\nimport \"./fire.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass FireMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public UV1 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public BonesPerMesh = 0;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FireMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"distortionTexture\")\r\n    private _distortionTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public distortionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture>;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public speed = 1.0;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n    private _lastTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FireMaterialDefines();\r\n        }\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture.isReady()) {\r\n                    return false;\r\n                } else {\r\n                    defines._needUVs = true;\r\n                    defines.DIFFUSE = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines.ALPHATEST = this._opacityTexture ? true : false;\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            defines.POINTSIZE = this.pointsCloud || scene.forcePointsCloud;\r\n            defines.FOG = scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && this.fogEnabled;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fire\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                // Fire\r\n                \"time\",\r\n                \"speed\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    {\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [],\r\n                        samplers: [\r\n                            \"diffuseSampler\",\r\n                            // Fire\r\n                            \"distortionSampler\",\r\n                            \"opacitySampler\",\r\n                        ],\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: null,\r\n                        maxSimultaneousLights: 4,\r\n                        transformFeedbackVaryings: null,\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FireMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n\r\n                this._activeEffect.setTexture(\"distortionSampler\", this._distortionTexture);\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Time\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", this._lastTime);\r\n\r\n        // Speed\r\n        this._activeEffect.setFloat(\"speed\", this.speed);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n        if (this._distortionTexture && this._distortionTexture.animations && this._distortionTexture.animations.length > 0) {\r\n            results.push(this._distortionTexture);\r\n        }\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            activeTextures.push(this._distortionTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._distortionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FireMaterial\";\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n        if (this._distortionTexture) {\r\n            this._distortionTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FireMaterial {\r\n        return SerializationHelper.Clone<FireMaterial>(() => new FireMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FireMaterial\";\r\n        serializationObject.diffuseColor = this.diffuseColor.asArray();\r\n        serializationObject.speed = this.speed;\r\n\r\n        if (this._diffuseTexture) {\r\n            serializationObject._diffuseTexture = this._diffuseTexture.serialize();\r\n        }\r\n\r\n        if (this._distortionTexture) {\r\n            serializationObject._distortionTexture = this._distortionTexture.serialize();\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            serializationObject._opacityTexture = this._opacityTexture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FireMaterial {\r\n        const material = new FireMaterial(source.name, scene);\r\n\r\n        material.diffuseColor = Color3.FromArray(source.diffuseColor);\r\n        material.speed = source.speed;\r\n\r\n        material.alpha = source.alpha;\r\n\r\n        material.id = source.id;\r\n\r\n        Tags.AddTagsTo(material, source.tags);\r\n        material.backFaceCulling = source.backFaceCulling;\r\n        material.wireframe = source.wireframe;\r\n\r\n        if (source._diffuseTexture) {\r\n            material._diffuseTexture = Texture.Parse(source._diffuseTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._distortionTexture) {\r\n            material._distortionTexture = Texture.Parse(source._distortionTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (source._opacityTexture) {\r\n            material._opacityTexture = Texture.Parse(source._opacityTexture, scene, rootUrl);\r\n        }\r\n\r\n        return material;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FireMaterial\", FireMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"furPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;uniform vec4 furColor;uniform float furLength;varying vec3 vPositionW;varying float vfur_length;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform float furOcclusion;uniform sampler2D furTexture;varying vec2 vFurUV;\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<fogFragmentDeclaration>\n#include<clipPlaneFragmentDeclaration>\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=furColor;vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nbaseColor*=texture2D(diffuseSampler,vDiffuseUV);\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef HIGHLEVEL\nvec4 furTextureColor=texture2D(furTexture,vec2(vFurUV.x,vFurUV.y));if (furTextureColor.a<=0.0 || furTextureColor.g<furOffset) {discard;}\nfloat occlusion=mix(0.0,furTextureColor.b*1.2,furOffset);baseColor=vec4(baseColor.xyz*max(occlusion,furOcclusion),1.1-furOffset);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase.rgb*baseColor.rgb,0.0,1.0);\n#ifdef HIGHLEVEL\nvec4 color=vec4(finalDiffuse,alpha);\n#else\nfloat r=vfur_length/furLength*0.5;vec4 color=vec4(finalDiffuse*(0.5+r),alpha);\n#endif\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const furPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"furVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;attribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\nuniform float furLength;uniform float furAngle;\n#ifdef HIGHLEVEL\nuniform float furOffset;uniform vec3 furGravity;uniform float furTime;uniform float furSpacing;uniform float furDensity;\n#endif\n#ifdef HEIGHTMAP\nuniform sampler2D heightTexture;\n#endif\n#ifdef HIGHLEVEL\nvarying vec2 vFurUV;\n#endif\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\nvarying float vfur_length;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\nfloat Rand(vec3 rv) {float x=dot(rv,vec3(12.9898,78.233,24.65487));return fract(sin(x)*43758.5453);}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nfloat r=Rand(position);\n#ifdef HEIGHTMAP\n#if __VERSION__>100\nvfur_length=furLength*texture(heightTexture,uv).x;\n#else\nvfur_length=furLength*texture2D(heightTexture,uv).r;\n#endif\n#else \nvfur_length=(furLength*r);\n#endif\nvec3 tangent1=vec3(normal.y,-normal.x,0);vec3 tangent2=vec3(-normal.z,0,normal.x);r=Rand(tangent1*r);float J=(2.0+4.0*r);r=Rand(tangent2*r);float K=(2.0+2.0*r);tangent1=tangent1*J+tangent2*K;tangent1=normalize(tangent1);vec3 newPosition=position+normal*vfur_length*cos(furAngle)+tangent1*vfur_length*sin(furAngle);\n#ifdef HIGHLEVEL\nvec3 forceDirection=vec3(0.0,0.0,0.0);forceDirection.x=sin(furTime+position.x*0.05)*0.2;forceDirection.y=cos(furTime*0.7+position.y*0.04)*0.2;forceDirection.z=sin(furTime*0.7+position.z*0.04)*0.2;vec3 displacement=vec3(0.0,0.0,0.0);displacement=furGravity+forceDirection;float displacementFactor=pow(furOffset,3.0);vec3 aNormal=normal;aNormal.xyz+=displacement*displacementFactor;newPosition=vec3(newPosition.x,newPosition.y,newPosition.z)+(normalize(aNormal)*furOffset*furSpacing);\n#endif\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\ngl_Position=viewProjection*finalWorld*vec4(newPosition,1.0);vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#ifdef HIGHLEVEL\nvFurUV=vDiffuseUV*furDensity;\n#endif\n#else\n#ifdef HIGHLEVEL\nvFurUV=uv*furDensity;\n#endif\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const furVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Tags } from \"core/Misc/tags\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\n\r\nimport \"./fur.fragment\";\r\nimport \"./fur.vertex\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass FurMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public HEIGHTMAP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public HIGHLEVEL = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class FurMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"heightTexture\")\r\n    private _heightTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public heightTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize()\r\n    public furLength: number = 1;\r\n\r\n    @serialize()\r\n    public furAngle: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public furColor = new Color3(0.44, 0.21, 0.02);\r\n\r\n    @serialize()\r\n    public furOffset: number = 0.0;\r\n\r\n    @serialize()\r\n    public furSpacing: number = 12;\r\n\r\n    @serializeAsVector3()\r\n    public furGravity = new Vector3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public furSpeed: number = 100;\r\n\r\n    @serialize()\r\n    public furDensity: number = 20;\r\n\r\n    @serialize()\r\n    public furOcclusion: number = 0.0;\r\n\r\n    public furTexture: DynamicTexture;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize()\r\n    public highLevelFur: boolean = true;\r\n\r\n    public _meshes: AbstractMesh[];\r\n\r\n    private _furTime: number = 0;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    @serialize()\r\n    public get furTime() {\r\n        return this._furTime;\r\n    }\r\n\r\n    public set furTime(furTime: number) {\r\n        this._furTime = furTime;\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public updateFur(): void {\r\n        for (let i = 1; i < this._meshes.length; i++) {\r\n            const offsetFur = <FurMaterial>this._meshes[i].material;\r\n\r\n            offsetFur.furLength = this.furLength;\r\n            offsetFur.furAngle = this.furAngle;\r\n            offsetFur.furGravity = this.furGravity;\r\n            offsetFur.furSpacing = this.furSpacing;\r\n            offsetFur.furSpeed = this.furSpeed;\r\n            offsetFur.furColor = this.furColor;\r\n            offsetFur.diffuseTexture = this.diffuseTexture;\r\n            offsetFur.furTexture = this.furTexture;\r\n            offsetFur.highLevelFur = this.highLevelFur;\r\n            offsetFur.furTime = this.furTime;\r\n            offsetFur.furDensity = this.furDensity;\r\n        }\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new FurMaterialDefines();\r\n        }\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this.diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n                if (this.heightTexture && engine.getCaps().maxVertexTextureImageUnits) {\r\n                    if (!this.heightTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.HEIGHTMAP = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // High level\r\n        if (this.highLevelFur !== defines.HIGHLEVEL) {\r\n            defines.HIGHLEVEL = true;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"fur\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"furLength\",\r\n                \"furAngle\",\r\n                \"furColor\",\r\n                \"furOffset\",\r\n                \"furGravity\",\r\n                \"furTime\",\r\n                \"furSpacing\",\r\n                \"furDensity\",\r\n                \"furOcclusion\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers = [\"diffuseSampler\", \"heightTexture\", \"furTexture\"];\r\n\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <FurMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (scene.getCachedMaterial() !== this) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this._heightTexture) {\r\n                this._activeEffect.setTexture(\"heightTexture\", this._heightTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(this._activeEffect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"furLength\", this.furLength);\r\n        this._activeEffect.setFloat(\"furAngle\", this.furAngle);\r\n        this._activeEffect.setColor4(\"furColor\", this.furColor, 1.0);\r\n\r\n        if (this.highLevelFur) {\r\n            this._activeEffect.setVector3(\"furGravity\", this.furGravity);\r\n            this._activeEffect.setFloat(\"furOffset\", this.furOffset);\r\n            this._activeEffect.setFloat(\"furSpacing\", this.furSpacing);\r\n            this._activeEffect.setFloat(\"furDensity\", this.furDensity);\r\n            this._activeEffect.setFloat(\"furOcclusion\", this.furOcclusion);\r\n\r\n            this._furTime += this.getScene().getEngine().getDeltaTime() / this.furSpeed;\r\n            this._activeEffect.setFloat(\"furTime\", this._furTime);\r\n\r\n            this._activeEffect.setTexture(\"furTexture\", this.furTexture);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.heightTexture && this.heightTexture.animations && this.heightTexture.animations.length > 0) {\r\n            results.push(this.heightTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._heightTexture) {\r\n            activeTextures.push(this._heightTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._heightTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        if (this._meshes) {\r\n            for (let i = 1; i < this._meshes.length; i++) {\r\n                const mat = this._meshes[i].material;\r\n\r\n                if (mat) {\r\n                    mat.dispose(forceDisposeEffect);\r\n                }\r\n                this._meshes[i].dispose();\r\n            }\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): FurMaterial {\r\n        return SerializationHelper.Clone(() => new FurMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.FurMaterial\";\r\n\r\n        if (this._meshes) {\r\n            serializationObject.sourceMeshName = this._meshes[0].name;\r\n            serializationObject.quality = this._meshes.length;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"FurMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): FurMaterial {\r\n        const material = SerializationHelper.Parse(() => new FurMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.sourceMeshName && material.highLevelFur) {\r\n            scene.executeWhenReady(() => {\r\n                const sourceMesh = <Mesh>scene.getMeshByName(source.sourceMeshName);\r\n                if (sourceMesh) {\r\n                    const furTexture = FurMaterial.GenerateTexture(\"Fur Texture\", scene);\r\n                    material.furTexture = furTexture;\r\n                    FurMaterial.FurifyMesh(sourceMesh, source.quality);\r\n                }\r\n            });\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    public static GenerateTexture(name: string, scene: Scene): DynamicTexture {\r\n        // Generate fur textures\r\n        const texture = new DynamicTexture(\"FurTexture \" + name, 256, scene, true);\r\n        const context = texture.getContext();\r\n\r\n        for (let i = 0; i < 20000; ++i) {\r\n            context.fillStyle = \"rgba(255, \" + Math.floor(Math.random() * 255) + \", \" + Math.floor(Math.random() * 255) + \", 1)\";\r\n            context.fillRect(Math.random() * texture.getSize().width, Math.random() * texture.getSize().height, 2, 2);\r\n        }\r\n\r\n        texture.update(false);\r\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\r\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\r\n\r\n        return texture;\r\n    }\r\n\r\n    // Creates and returns an array of meshes used as shells for the Fur Material\r\n    // that can be disposed later in your code\r\n    // The quality is in interval [0, 100]\r\n    public static FurifyMesh(sourceMesh: Mesh, quality: number): Mesh[] {\r\n        const meshes = [sourceMesh];\r\n        const mat: FurMaterial = <FurMaterial>sourceMesh.material;\r\n        let i;\r\n\r\n        if (!(mat instanceof FurMaterial)) {\r\n            throw \"The material of the source mesh must be a Fur Material\";\r\n        }\r\n\r\n        for (i = 1; i < quality; i++) {\r\n            const offsetFur = new FurMaterial(mat.name + i, sourceMesh.getScene());\r\n            sourceMesh.getScene().materials.pop();\r\n            Tags.EnableFor(offsetFur);\r\n            Tags.AddTagsTo(offsetFur, \"furShellMaterial\");\r\n\r\n            offsetFur.furLength = mat.furLength;\r\n            offsetFur.furAngle = mat.furAngle;\r\n            offsetFur.furGravity = mat.furGravity;\r\n            offsetFur.furSpacing = mat.furSpacing;\r\n            offsetFur.furSpeed = mat.furSpeed;\r\n            offsetFur.furColor = mat.furColor;\r\n            offsetFur.diffuseTexture = mat.diffuseTexture;\r\n            offsetFur.furOffset = i / quality;\r\n            offsetFur.furTexture = mat.furTexture;\r\n            offsetFur.highLevelFur = mat.highLevelFur;\r\n            offsetFur.furTime = mat.furTime;\r\n            offsetFur.furDensity = mat.furDensity;\r\n\r\n            const offsetMesh = sourceMesh.clone(sourceMesh.name + i) as Mesh;\r\n\r\n            offsetMesh.material = offsetFur;\r\n            offsetMesh.skeleton = sourceMesh.skeleton;\r\n            offsetMesh.position = Vector3.Zero();\r\n            meshes.push(offsetMesh);\r\n        }\r\n\r\n        for (i = 1; i < meshes.length; i++) {\r\n            meshes[i].parent = sourceMesh;\r\n        }\r\n\r\n        (<FurMaterial>sourceMesh.material)._meshes = meshes;\r\n\r\n        return meshes;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FurMaterial\", FurMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gradientPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 topColor;\runiform vec4 bottomColor;\runiform float offset;\runiform float scale;\runiform float smoothness;\rvarying vec3 vPositionW;\rvarying vec3 vPosition;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rfloat h=vPosition.y*scale+offset;\rfloat mysmoothness=clamp(smoothness,0.01,max(smoothness,10.));\rvec4 baseColor=mix(bottomColor,topColor,max(pow(max(h,0.0),mysmoothness),0.0));\rvec3 diffuseColor=baseColor.rgb;\rfloat alpha=baseColor.a;\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\n#ifdef EMISSIVE\nvec3 diffuseBase=baseColor.rgb;\r#else\nvec3 diffuseBase=vec3(0.,0.,0.);\r#endif\nlightingInfo info;\rfloat shadow=1.;\rfloat glossiness=0.;\r#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\rvec4 color=vec4(finalDiffuse,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gradientPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"gradientVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\rvarying vec3 vPosition;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\rvPosition=position;\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gradientVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./gradient.fragment\";\r\nimport \"./gradient.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass GradientMaterialDefines extends MaterialDefines {\r\n    public EMISSIVE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class GradientMaterial extends PushMaterial {\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    // The gradient top color, red by default\r\n    @serializeAsColor3()\r\n    public topColor = new Color3(1, 0, 0);\r\n\r\n    @serialize()\r\n    public topColorAlpha = 1.0;\r\n\r\n    // The gradient top color, blue by default\r\n    @serializeAsColor3()\r\n    public bottomColor = new Color3(0, 0, 1);\r\n\r\n    @serialize()\r\n    public bottomColorAlpha = 1.0;\r\n\r\n    // Gradient offset\r\n    @serialize()\r\n    public offset = 0;\r\n\r\n    @serialize()\r\n    public scale = 1.0;\r\n\r\n    @serialize()\r\n    public smoothness = 1.0;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this.topColorAlpha < 1.0 || this.bottomColorAlpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GradientMaterialDefines();\r\n        }\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        defines.EMISSIVE = this._disableLighting;\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"gradient\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"topColor\",\r\n                \"bottomColor\",\r\n                \"offset\",\r\n                \"smoothness\",\r\n                \"scale\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const samplers: string[] = [];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GradientMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setColor4(\"topColor\", this.topColor, this.topColorAlpha);\r\n        this._activeEffect.setColor4(\"bottomColor\", this.bottomColor, this.bottomColorAlpha);\r\n        this._activeEffect.setFloat(\"offset\", this.offset);\r\n        this._activeEffect.setFloat(\"scale\", this.scale);\r\n        this._activeEffect.setFloat(\"smoothness\", this.smoothness);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GradientMaterial {\r\n        return SerializationHelper.Clone(() => new GradientMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GradientMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GradientMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GradientMaterial {\r\n        return SerializationHelper.Parse(() => new GradientMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GradientMaterial\", GradientMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"gridPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\n#define SQRT2 1.41421356\n#define PI 3.14159\nprecision highp float;\runiform float visibility;\runiform vec3 mainColor;\runiform vec3 lineColor;\runiform vec4 gridControl;\runiform vec3 gridOffset;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogFragmentDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform sampler2D opacitySampler;\runiform vec2 vOpacityInfos;\r#endif\nfloat getDynamicVisibility(float position) {\rfloat majorGridFrequency=gridControl.y;\rif (floor(position+0.5)==floor(position/majorGridFrequency+0.5)*majorGridFrequency)\r{\rreturn 1.0;\r} \rreturn gridControl.z;\r}\rfloat getAnisotropicAttenuation(float differentialLength) {\rconst float maxNumberOfLines=10.0;\rreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\r}\rfloat isPointOnLine(float position,float differentialLength) {\rfloat fractionPartOfPosition=position-floor(position+0.5); \rfractionPartOfPosition/=differentialLength; \rfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\rfloat result=0.5+0.5*cos(fractionPartOfPosition*PI); \rreturn result; \r}\rfloat contributionOnAxis(float position) {\rfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\rdifferentialLength*=SQRT2; \rfloat result=isPointOnLine(position,differentialLength);\rfloat dynamicVisibility=getDynamicVisibility(position);\rresult*=dynamicVisibility;\rfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\rresult*=anisotropicAttenuation;\rreturn result;\r}\rfloat normalImpactOnAxis(float x) {\rfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\rreturn normalImpact;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\nfloat gridRatio=gridControl.x;\rvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\rfloat x=contributionOnAxis(gridPos.x);\rfloat y=contributionOnAxis(gridPos.y);\rfloat z=contributionOnAxis(gridPos.z);\rvec3 normal=normalize(vNormal);\rx*=normalImpactOnAxis(normal.x);\ry*=normalImpactOnAxis(normal.y);\rz*=normalImpactOnAxis(normal.z);\r#ifdef MAX_LINE \nfloat grid=clamp(max(max(x,y),z),0.,1.);\r#else\nfloat grid=clamp(x+y+z,0.,1.);\r#endif\nvec3 color=mix(mainColor,lineColor,grid);\r#ifdef FOG\n#include<fogFragment>\n#endif\nfloat opacity=1.0;\r#ifdef TRANSPARENT\nopacity=clamp(grid,0.08,gridControl.w*grid);\r#endif \n#ifdef OPACITY\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\r#endif \ngl_FragColor=vec4(color.rgb,opacity*visibility);\r#ifdef TRANSPARENT\n#ifdef PREMULTIPLYALPHA\ngl_FragColor.rgb*=opacity;\r#endif\n#else \n#endif\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\n\nconst name = \"gridVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\rattribute vec3 normal;\r#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#include<instancesDeclaration>\nuniform mat4 projection;\runiform mat4 view;\rvarying vec3 vPosition;\rvarying vec3 vNormal;\r#include<fogVertexDeclaration>\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\runiform mat4 opacityMatrix;\runiform vec2 vOpacityInfos;\r#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\nvec4 worldPos=finalWorld*vec4(position,1.0);\r#include<fogVertex>\nvec4 cameraSpacePosition=view*worldPos;\rgl_Position=projection*cameraSpacePosition;\r#ifdef OPACITY\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\nif (vOpacityInfos.x==0.)\r{\rvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\r}\r#endif \nvPosition=position;\rvNormal=normal;\r#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gridVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper, serializeAsVector3 } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector4, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./grid.fragment\";\r\nimport \"./grid.vertex\";\r\n\r\nclass GridMaterialDefines extends MaterialDefines {\r\n    public OPACITY = false;\r\n    public TRANSPARENT = false;\r\n    public FOG = false;\r\n    public PREMULTIPLYALPHA = false;\r\n    public MAX_LINE = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nexport class GridMaterial extends PushMaterial {\r\n    /**\r\n     * Main color of the grid (e.g. between lines)\r\n     */\r\n    @serializeAsColor3()\r\n    public mainColor = Color3.Black();\r\n\r\n    /**\r\n     * Color of the grid lines.\r\n     */\r\n    @serializeAsColor3()\r\n    public lineColor = Color3.Teal();\r\n\r\n    /**\r\n     * The scale of the grid compared to unit.\r\n     */\r\n    @serialize()\r\n    public gridRatio = 1.0;\r\n\r\n    /**\r\n     * Allows setting an offset for the grid lines.\r\n     */\r\n    @serializeAsVector3()\r\n    public gridOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * The frequency of thicker lines.\r\n     */\r\n    @serialize()\r\n    public majorUnitFrequency = 10;\r\n\r\n    /**\r\n     * The visibility of minor units in the grid.\r\n     */\r\n    @serialize()\r\n    public minorUnitVisibility = 0.33;\r\n\r\n    /**\r\n     * The grid opacity outside of the lines.\r\n     */\r\n    @serialize()\r\n    public opacity = 1.0;\r\n\r\n    /**\r\n     * Determine RBG output is premultiplied by alpha value.\r\n     */\r\n    @serialize()\r\n    public preMultiplyAlpha = false;\r\n\r\n    /**\r\n     * Determines if the max line value will be used instead of the sum wherever grid lines intersect.\r\n     */\r\n    @serialize()\r\n    public useMaxLine = false;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public opacityTexture: BaseTexture;\r\n\r\n    private _gridControl: Vector4 = new Vector4(this.gridRatio, this.majorUnitFrequency, this.minorUnitVisibility, this.opacity);\r\n\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the grid requires alpha blending.\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.opacity < 1.0 || (this._opacityTexture && this._opacityTexture.isReady());\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return mesh.visibility < 1.0 || this.needAlphaBlending();\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new GridMaterialDefines();\r\n        }\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        if (defines.TRANSPARENT !== this.opacity < 1.0) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (defines.MAX_LINE !== this.useMaxLine) {\r\n            defines.MAX_LINE = !defines.MAX_LINE;\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, scene.getEngine(), this, defines, !!useInstances);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Attributes\r\n            MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Defines\r\n            const join = defines.toString();\r\n            subMesh.setEffect(\r\n                scene\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"grid\",\r\n                        attribs,\r\n                        [\r\n                            \"projection\",\r\n                            \"mainColor\",\r\n                            \"lineColor\",\r\n                            \"gridControl\",\r\n                            \"gridOffset\",\r\n                            \"vFogInfos\",\r\n                            \"vFogColor\",\r\n                            \"world\",\r\n                            \"view\",\r\n                            \"opacityMatrix\",\r\n                            \"vOpacityInfos\",\r\n                            \"visibility\",\r\n                        ],\r\n                        [\"opacitySampler\"],\r\n                        join,\r\n                        undefined,\r\n                        this.onCompiled,\r\n                        this.onError\r\n                    ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GridMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        this._activeEffect.setFloat(\"visibility\", mesh.visibility);\r\n\r\n        // Matrices\r\n        if (!defines.INSTANCES || defines.THIN_INSTANCE) {\r\n            this.bindOnlyWorldMatrix(world);\r\n        }\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n\r\n            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n        }\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): GridMaterial {\r\n        return SerializationHelper.Clone(() => new GridMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"GridMaterial\";\r\n    }\r\n\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): GridMaterial {\r\n        return SerializationHelper.Parse(() => new GridMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GridMaterial\", GridMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"lavaPixelShader\";\nconst shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;uniform float time;uniform float speed;uniform float movingSpeed;uniform vec3 fogColor;uniform sampler2D noiseTexture;uniform float fogDensity;varying float noise;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\nfloat random( vec3 scale,float seed ){return fract( sin( dot( gl_FragCoord.xyz+seed,scale ) )*43758.5453+seed ) ;}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef DIFFUSE\nvec4 noiseTex=texture2D( noiseTexture,vDiffuseUV );vec2 T1=vDiffuseUV+vec2( 1.5,-1.5 )*time *0.02;vec2 T2=vDiffuseUV+vec2( -0.5,2.0 )*time*0.01*speed;T1.x+=noiseTex.x*2.0;T1.y+=noiseTex.y*2.0;T2.x-=noiseTex.y*0.2+time*0.001*movingSpeed;T2.y+=noiseTex.z*0.2+time*0.002*movingSpeed;float p=texture2D( noiseTexture,T1*3.0 ).a;vec4 lavaColor=texture2D( diffuseSampler,T2*4.0);vec4 temp=lavaColor*( vec4( p,p,p,p )*2. )+( lavaColor*lavaColor-0.1 );baseColor=temp;float depth=gl_FragCoord.z*4.0;const float LOG2=1.442695;float fogFactor=exp2(-fogDensity*fogDensity*depth*depth*LOG2 );fogFactor=1.0-clamp( fogFactor,0.0,1.0 );baseColor=mix( baseColor,vec4( fogColor,baseColor.w ),fogFactor );diffuseColor=baseColor.rgb;\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\ndiscard;\n#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef VERTEXCOLOR\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n#ifdef UNLIT\nvec3 diffuseBase=vec3(1.,1.,1.);\n#else\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;\n#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;vec4 color=vec4(finalDiffuse,alpha);\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lavaPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"lavaVertexShader\";\nconst shader = `precision highp float;uniform float time;uniform float lowFrequencySpeed;varying float noise;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n/* NOISE FUNCTIONS */\nvec3 mod289(vec3 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 mod289(vec4 x)\n{return x-floor(x*(1.0/289.0))*289.0;}\nvec4 permute(vec4 x)\n{return mod289(((x*34.0)+1.0)*x);}\nvec4 taylorInvSqrt(vec4 r)\n{return 1.79284291400159-0.85373472095314*r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat pnoise(vec3 P,vec3 rep)\n{vec3 Pi0=mod(floor(P),rep); \nvec3 Pi1=mod(Pi0+vec3(1.0),rep); \nPi0=mod289(Pi0);Pi1=mod289(Pi1);vec3 Pf0=fract(P); \nvec3 Pf1=Pf0-vec3(1.0); \nvec4 ix=vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);vec4 iy=vec4(Pi0.yy,Pi1.yy);vec4 iz0=Pi0.zzzz;vec4 iz1=Pi1.zzzz;vec4 ixy=permute(permute(ix)+iy);vec4 ixy0=permute(ixy+iz0);vec4 ixy1=permute(ixy+iz1);vec4 gx0=ixy0*(1.0/7.0);vec4 gy0=fract(floor(gx0)*(1.0/7.0))-0.5;gx0=fract(gx0);vec4 gz0=vec4(0.5)-abs(gx0)-abs(gy0);vec4 sz0=step(gz0,vec4(0.0));gx0-=sz0*(step(0.0,gx0)-0.5);gy0-=sz0*(step(0.0,gy0)-0.5);vec4 gx1=ixy1*(1.0/7.0);vec4 gy1=fract(floor(gx1)*(1.0/7.0))-0.5;gx1=fract(gx1);vec4 gz1=vec4(0.5)-abs(gx1)-abs(gy1);vec4 sz1=step(gz1,vec4(0.0));gx1-=sz1*(step(0.0,gx1)-0.5);gy1-=sz1*(step(0.0,gy1)-0.5);vec3 g000=vec3(gx0.x,gy0.x,gz0.x);vec3 g100=vec3(gx0.y,gy0.y,gz0.y);vec3 g010=vec3(gx0.z,gy0.z,gz0.z);vec3 g110=vec3(gx0.w,gy0.w,gz0.w);vec3 g001=vec3(gx1.x,gy1.x,gz1.x);vec3 g101=vec3(gx1.y,gy1.y,gz1.y);vec3 g011=vec3(gx1.z,gy1.z,gz1.z);vec3 g111=vec3(gx1.w,gy1.w,gz1.w);vec4 norm0=taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));g000*=norm0.x;g010*=norm0.y;g100*=norm0.z;g110*=norm0.w;vec4 norm1=taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));g001*=norm1.x;g011*=norm1.y;g101*=norm1.z;g111*=norm1.w;float n000=dot(g000,Pf0);float n100=dot(g100,vec3(Pf1.x,Pf0.yz));float n010=dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));float n110=dot(g110,vec3(Pf1.xy,Pf0.z));float n001=dot(g001,vec3(Pf0.xy,Pf1.z));float n101=dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));float n011=dot(g011,vec3(Pf0.x,Pf1.yz));float n111=dot(g111,Pf1);vec3 fade_xyz=fade(Pf0);vec4 n_z=mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);vec2 n_yz=mix(n_z.xy,n_z.zw,fade_xyz.y);float n_xyz=mix(n_yz.x,n_yz.y,fade_xyz.x);return 2.2*n_xyz;}\n/* END FUNCTION */\nfloat turbulence( vec3 p ) {float w=100.0;float t=-.5;for (float f=1.0 ; f<=10.0 ; f++ ){float power=pow( 2.0,f );t+=abs( pnoise( vec3( power*p ),vec3( 10.0,10.0,10.0 ) )/power );}\nreturn t;}\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n#ifdef NORMAL\nnoise=10.0* -.10*turbulence( .5*normal+time*1.15 );float b=lowFrequencySpeed*5.0*pnoise( 0.05*position +vec3(time*1.025),vec3( 100.0 ) );float displacement=- 1.5*noise+b;vec3 newPosition=position+normal*displacement;gl_Position=viewProjection*finalWorld*vec4( newPosition,1.0 );vec4 worldPos=finalWorld*vec4(newPosition,1.0);vPositionW=vec3(worldPos);vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}\nelse\n{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const lavaVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./lava.fragment\";\r\nimport \"./lava.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass LavaMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public UNLIT = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class LavaMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsTexture()\r\n    public noiseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public fogColor: Color3;\r\n\r\n    @serialize()\r\n    public speed: number = 1;\r\n\r\n    @serialize()\r\n    public movingSpeed: number = 1;\r\n\r\n    @serialize()\r\n    public lowFrequencySpeed: number = 1;\r\n\r\n    @serialize()\r\n    public fogDensity: number = 0.15;\r\n\r\n    private _lastTime: number = 0;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"unlit\")\r\n    private _unlit = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public unlit: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    private _scaledDiffuse = new Color3();\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new LavaMaterialDefines();\r\n        }\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"lava\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"time\",\r\n                \"speed\",\r\n                \"movingSpeed\",\r\n                \"fogColor\",\r\n                \"fogDensity\",\r\n                \"lowFrequencySpeed\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const samplers = [\"diffuseSampler\", \"noiseTexture\"];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <LavaMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        defines.UNLIT = this._unlit;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            if (this.noiseTexture) {\r\n                this._activeEffect.setTexture(\"noiseTexture\", this.noiseTexture);\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this._scaledDiffuse, this.alpha * mesh.visibility);\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._lastTime += scene.getEngine().getDeltaTime();\r\n        this._activeEffect.setFloat(\"time\", (this._lastTime * this.speed) / 1000);\r\n\r\n        if (!this.fogColor) {\r\n            this.fogColor = Color3.Black();\r\n        }\r\n        this._activeEffect.setColor3(\"fogColor\", this.fogColor);\r\n        this._activeEffect.setFloat(\"fogDensity\", this.fogDensity);\r\n\r\n        this._activeEffect.setFloat(\"lowFrequencySpeed\", this.lowFrequencySpeed);\r\n        this._activeEffect.setFloat(\"movingSpeed\", this.movingSpeed);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        if (this.noiseTexture && this.noiseTexture.animations && this.noiseTexture.animations.length > 0) {\r\n            results.push(this.noiseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n        if (this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): LavaMaterial {\r\n        return SerializationHelper.Clone(() => new LavaMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.LavaMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"LavaMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): LavaMaterial {\r\n        return SerializationHelper.Parse(() => new LavaMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LavaMaterial\", LavaMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"mixPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\runiform sampler2D mixMap1Sampler;\runiform vec2 vTextureInfos;\r#ifdef MIXMAP2\nuniform sampler2D mixMap2Sampler;\r#endif\nuniform sampler2D diffuse1Sampler;\runiform sampler2D diffuse2Sampler;\runiform sampler2D diffuse3Sampler;\runiform sampler2D diffuse4Sampler;\runiform vec2 diffuse1Infos;\runiform vec2 diffuse2Infos;\runiform vec2 diffuse3Infos;\runiform vec2 diffuse4Infos;\r#ifdef MIXMAP2\nuniform sampler2D diffuse5Sampler;\runiform sampler2D diffuse6Sampler;\runiform sampler2D diffuse7Sampler;\runiform sampler2D diffuse8Sampler;\runiform vec2 diffuse5Infos;\runiform vec2 diffuse6Infos;\runiform vec2 diffuse7Infos;\runiform vec2 diffuse8Infos;\r#endif\n#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 finalMixColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\r#ifdef MIXMAP2\nvec4 mixColor2=vec4(1.,1.,1.,1.);\r#endif\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\nfloat alpha=vDiffuseColor.a;\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\n#ifdef DIFFUSE\nvec4 mixColor=texture2D(mixMap1Sampler,vTextureUV);\r#include<depthPrePass>\nmixColor.rgb*=vTextureInfos.y;\rvec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);\rvec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);\rvec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);\rvec4 diffuse4Color=texture2D(diffuse4Sampler,vTextureUV*diffuse4Infos);\rdiffuse1Color.rgb*=mixColor.r;\rdiffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,mixColor.g);\rdiffuse3Color.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,mixColor.b);\rfinalMixColor.rgb=mix(diffuse3Color.rgb,diffuse4Color.rgb,1.0-mixColor.a);\r#ifdef MIXMAP2\nmixColor=texture2D(mixMap2Sampler,vTextureUV);\rmixColor.rgb*=vTextureInfos.y;\rvec4 diffuse5Color=texture2D(diffuse5Sampler,vTextureUV*diffuse5Infos);\rvec4 diffuse6Color=texture2D(diffuse6Sampler,vTextureUV*diffuse6Infos);\rvec4 diffuse7Color=texture2D(diffuse7Sampler,vTextureUV*diffuse7Infos);\rvec4 diffuse8Color=texture2D(diffuse8Sampler,vTextureUV*diffuse8Infos);\rdiffuse5Color.rgb=mix(finalMixColor.rgb,diffuse5Color.rgb,mixColor.r);\rdiffuse6Color.rgb=mix(diffuse5Color.rgb,diffuse6Color.rgb,mixColor.g);\rdiffuse7Color.rgb=mix(diffuse6Color.rgb,diffuse7Color.rgb,mixColor.b);\rfinalMixColor.rgb=mix(diffuse7Color.rgb,diffuse8Color.rgb,1.0-mixColor.a);\r#endif\n#endif\n#ifdef VERTEXCOLOR\nfinalMixColor.rgb*=vColor.rgb;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*finalMixColor.rgb,0.0,1.0);\rvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const mixPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"mixVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const mixVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./mix.fragment\";\r\nimport \"./mix.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass MixMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public MIXMAP2 = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class MixMaterial extends PushMaterial {\r\n    /**\r\n     * Mix textures\r\n     */\r\n\r\n    @serializeAsTexture(\"mixTexture1\")\r\n    private _mixTexture1: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture1: BaseTexture;\r\n\r\n    @serializeAsTexture(\"mixTexture2\")\r\n    private _mixTexture2: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture2: BaseTexture;\r\n\r\n    /**\r\n     * Diffuse textures\r\n     */\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture4: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture4: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture5: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture5: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture6: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture6: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture7: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture7: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture4\")\r\n    private _diffuseTexture8: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture8: Texture;\r\n\r\n    /**\r\n     * Uniforms\r\n     */\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new MixMaterialDefines();\r\n        }\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this._mixTexture1 || !this._mixTexture1.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this._diffuseTexture1 || !this._diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n\r\n                if (!this._diffuseTexture2 || !this._diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture3 || !this._diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this._diffuseTexture4 || !this._diffuseTexture4.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                if (this._mixTexture2) {\r\n                    if (!this._mixTexture2.isReady()) {\r\n                        return false;\r\n                    }\r\n\r\n                    defines.MIXMAP2 = true;\r\n\r\n                    if (!this._diffuseTexture5 || !this._diffuseTexture5.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture6 || !this._diffuseTexture6.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture7 || !this._diffuseTexture7.isReady()) {\r\n                        return false;\r\n                    }\r\n                    if (!this._diffuseTexture8 || !this._diffuseTexture8.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"mix\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n                \"diffuse4Infos\",\r\n                \"diffuse5Infos\",\r\n                \"diffuse6Infos\",\r\n                \"diffuse7Infos\",\r\n                \"diffuse8Infos\",\r\n            ];\r\n            const samplers = [\r\n                \"mixMap1Sampler\",\r\n                \"mixMap2Sampler\",\r\n                \"diffuse1Sampler\",\r\n                \"diffuse2Sampler\",\r\n                \"diffuse3Sampler\",\r\n                \"diffuse4Sampler\",\r\n                \"diffuse5Sampler\",\r\n                \"diffuse6Sampler\",\r\n                \"diffuse7Sampler\",\r\n                \"diffuse8Sampler\",\r\n            ];\r\n\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <MixMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._mixTexture1) {\r\n                this._activeEffect.setTexture(\"mixMap1Sampler\", this._mixTexture1);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture1.coordinatesIndex, this._mixTexture1.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture1.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                    if (this._diffuseTexture4) {\r\n                        this._activeEffect.setTexture(\"diffuse4Sampler\", this._diffuseTexture4);\r\n                        this._activeEffect.setFloat2(\"diffuse4Infos\", this._diffuseTexture4.uScale, this._diffuseTexture4.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._mixTexture2) {\r\n                this._activeEffect.setTexture(\"mixMap2Sampler\", this._mixTexture2);\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture5) {\r\n                        this._activeEffect.setTexture(\"diffuse5Sampler\", this._diffuseTexture5);\r\n                        this._activeEffect.setFloat2(\"diffuse5Infos\", this._diffuseTexture5.uScale, this._diffuseTexture5.vScale);\r\n                    }\r\n                    if (this._diffuseTexture6) {\r\n                        this._activeEffect.setTexture(\"diffuse6Sampler\", this._diffuseTexture6);\r\n                        this._activeEffect.setFloat2(\"diffuse6Infos\", this._diffuseTexture6.uScale, this._diffuseTexture6.vScale);\r\n                    }\r\n                    if (this._diffuseTexture7) {\r\n                        this._activeEffect.setTexture(\"diffuse7Sampler\", this._diffuseTexture7);\r\n                        this._activeEffect.setFloat2(\"diffuse7Infos\", this._diffuseTexture7.uScale, this._diffuseTexture7.vScale);\r\n                    }\r\n                    if (this._diffuseTexture8) {\r\n                        this._activeEffect.setTexture(\"diffuse8Sampler\", this._diffuseTexture8);\r\n                        this._activeEffect.setFloat2(\"diffuse8Infos\", this._diffuseTexture8.uScale, this._diffuseTexture8.vScale);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._mixTexture1 && this._mixTexture1.animations && this._mixTexture1.animations.length > 0) {\r\n            results.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._mixTexture2 && this._mixTexture2.animations && this._mixTexture2.animations.length > 0) {\r\n            results.push(this._mixTexture2);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1) {\r\n            activeTextures.push(this._mixTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._diffuseTexture4) {\r\n            activeTextures.push(this._diffuseTexture4);\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2) {\r\n            activeTextures.push(this._mixTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture5) {\r\n            activeTextures.push(this._diffuseTexture5);\r\n        }\r\n\r\n        if (this._diffuseTexture6) {\r\n            activeTextures.push(this._diffuseTexture6);\r\n        }\r\n\r\n        if (this._diffuseTexture7) {\r\n            activeTextures.push(this._diffuseTexture7);\r\n        }\r\n\r\n        if (this._diffuseTexture8) {\r\n            activeTextures.push(this._diffuseTexture8);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 1\r\n        if (this._mixTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture4 === texture) {\r\n            return true;\r\n        }\r\n\r\n        // Mix map 2\r\n        if (this._mixTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture5 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture6 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture7 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture8 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._mixTexture1) {\r\n            this._mixTexture1.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): MixMaterial {\r\n        return SerializationHelper.Clone(() => new MixMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.MixMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"MixMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): MixMaterial {\r\n        return SerializationHelper.Parse(() => new MixMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MixMaterial\", MixMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"normalPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\rvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef LIGHTING\n#include<helperFunctions>\n#include<__decl__lightFragment>[0]\n#include<__decl__lightFragment>[1]\n#include<__decl__lightFragment>[2]\n#include<__decl__lightFragment>[3]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#endif\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform sampler2D diffuseSampler;\runiform vec2 vDiffuseInfos;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\r#endif\n#ifdef NORMAL\nbaseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);\r#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\n#ifdef LIGHTING\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\rfloat glossiness=0.;\r#include<lightFragment>[0]\n#include<lightFragment>[1]\n#include<lightFragment>[2]\n#include<lightFragment>[3]\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\r#else\nvec3 finalDiffuse= baseColor.rgb;\r#endif\nvec4 color=vec4(finalDiffuse,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const normalPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"normalVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform mat4 diffuseMatrix;\runiform vec2 vDiffuseInfos;\r#endif\n#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const normalVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./normal.fragment\";\r\nimport \"./normal.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass NormalMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LIGHT0 = false;\r\n    public LIGHT1 = false;\r\n    public LIGHT2 = false;\r\n    public LIGHT3 = false;\r\n    public SPOTLIGHT0 = false;\r\n    public SPOTLIGHT1 = false;\r\n    public SPOTLIGHT2 = false;\r\n    public SPOTLIGHT3 = false;\r\n    public HEMILIGHT0 = false;\r\n    public HEMILIGHT1 = false;\r\n    public HEMILIGHT2 = false;\r\n    public HEMILIGHT3 = false;\r\n    public DIRLIGHT0 = false;\r\n    public DIRLIGHT1 = false;\r\n    public DIRLIGHT2 = false;\r\n    public DIRLIGHT3 = false;\r\n    public POINTLIGHT0 = false;\r\n    public POINTLIGHT1 = false;\r\n    public POINTLIGHT2 = false;\r\n    public POINTLIGHT3 = false;\r\n    public SHADOW0 = false;\r\n    public SHADOW1 = false;\r\n    public SHADOW2 = false;\r\n    public SHADOW3 = false;\r\n    public SHADOWS = false;\r\n    public SHADOWESM0 = false;\r\n    public SHADOWESM1 = false;\r\n    public SHADOWESM2 = false;\r\n    public SHADOWESM3 = false;\r\n    public SHADOWPOISSON0 = false;\r\n    public SHADOWPOISSON1 = false;\r\n    public SHADOWPOISSON2 = false;\r\n    public SHADOWPOISSON3 = false;\r\n    public SHADOWPCF0 = false;\r\n    public SHADOWPCF1 = false;\r\n    public SHADOWPCF2 = false;\r\n    public SHADOWPCF3 = false;\r\n    public SHADOWPCSS0 = false;\r\n    public SHADOWPCSS1 = false;\r\n    public SHADOWPCSS2 = false;\r\n    public SHADOWPCSS3 = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public LIGHTING = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class NormalMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        return this.needAlphaBlending() || mesh.visibility < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NormalMaterialDefines();\r\n        }\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = true;\r\n        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        defines.LIGHTING = !this._disableLighting;\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"normal\";\r\n            const join = defines.toString();\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 4,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 4 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <NormalMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this.diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this.diffuseTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {\r\n            results.push(this.diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.diffuseTexture) {\r\n            this.diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): NormalMaterial {\r\n        return SerializationHelper.Clone(() => new NormalMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.NormalMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"NormalMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): NormalMaterial {\r\n        return SerializationHelper.Parse(() => new NormalMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NormalMaterial\", NormalMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"shadowOnlyPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform float alpha;\runiform vec3 shadowColor;\rvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\rfloat glossiness=0.;\r#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\n\nconst name = \"shadowOnlyVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const shadowOnlyVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./shadowOnly.fragment\";\r\nimport \"./shadowOnly.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { CascadedShadowGenerator } from \"core/Lights/Shadows/cascadedShadowGenerator\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass ShadowOnlyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class ShadowOnlyMaterial extends PushMaterial {\r\n    private _activeLight: IShadowLight;\r\n    private _needAlphaBlending = true;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public shadowColor = Color3.Black();\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this._needAlphaBlending;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public get activeLight(): IShadowLight {\r\n        return this._activeLight;\r\n    }\r\n\r\n    public set activeLight(light: IShadowLight) {\r\n        this._activeLight = light;\r\n    }\r\n\r\n    private _getFirstShadowLightForMesh(mesh: AbstractMesh): Nullable<IShadowLight> {\r\n        for (const light of mesh.lightSources) {\r\n            if (light.shadowEnabled) {\r\n                return light as IShadowLight;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new ShadowOnlyMaterialDefines();\r\n        }\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Ensure that active light is the first shadow light\r\n        if (this._activeLight) {\r\n            for (const light of mesh.lightSources) {\r\n                if (light.shadowEnabled) {\r\n                    if (this._activeLight === light) {\r\n                        break; // We are good\r\n                    }\r\n\r\n                    const lightPosition = mesh.lightSources.indexOf(this._activeLight);\r\n\r\n                    if (lightPosition !== -1) {\r\n                        mesh.lightSources.splice(lightPosition, 1);\r\n                        mesh.lightSources.splice(0, 0, this._activeLight);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, 1);\r\n\r\n        const shadowGenerator = this._getFirstShadowLightForMesh(mesh)?.getShadowGenerator();\r\n\r\n        this._needAlphaBlending = true;\r\n\r\n        if (shadowGenerator && (shadowGenerator as any).getClassName && (shadowGenerator as any).getClassName() === \"CascadedShadowGenerator\") {\r\n            const csg = shadowGenerator as CascadedShadowGenerator;\r\n\r\n            this._needAlphaBlending = !csg.autoCalcDepthBounds;\r\n        }\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, 1);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"shadowOnly\";\r\n            const join = defines.toString();\r\n            const uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"alpha\", \"shadowColor\", \"mBones\"];\r\n            const samplers = new Array<string>();\r\n\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: 1,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <ShadowOnlyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            this._activeEffect.setFloat(\"alpha\", this.alpha);\r\n            this._activeEffect.setColor3(\"shadowColor\", this.shadowColor);\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, 1);\r\n\r\n            const light = this._getFirstShadowLightForMesh(mesh);\r\n\r\n            if (light) {\r\n                // Make sure the uniforms for this light will be rebound for other materials using this light when rendering the current frame.\r\n                // Indeed, there is an optimization in Light that binds the light uniforms only once per frame for a given light (if using ubo).\r\n                // Doing this way assumes that all uses of this light are the same, meaning all parameters passed to Light._bindLlight\r\n                // are the same, notably useSpecular. However, isReadyForSubMesh (see above) is passing false for this parameter, which may not be\r\n                // the value the other materials may pass.\r\n                light._renderId = -1;\r\n            }\r\n        }\r\n\r\n        // View\r\n        if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || defines[\"SHADOWCSM0\"]) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public clone(name: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Clone<ShadowOnlyMaterial>(() => new ShadowOnlyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.ShadowOnlyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"ShadowOnlyMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShadowOnlyMaterial {\r\n        return SerializationHelper.Parse(() => new ShadowOnlyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShadowOnlyMaterial\", ShadowOnlyMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"simplePixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\rvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform sampler2D diffuseSampler;\runiform vec2 vDiffuseInfos;\r#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV);\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\nbaseColor.rgb*=vDiffuseInfos.y;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\rfloat glossiness=0.;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif \n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\rvec4 color=vec4(finalDiffuse,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const simplePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"simpleVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef DIFFUSE\nvarying vec2 vDiffuseUV;\runiform mat4 diffuseMatrix;\runiform vec2 vDiffuseInfos;\r#endif\n#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef DIFFUSE\nif (vDiffuseInfos.x==0.)\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\r}\relse\r{\rvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\r}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const simpleVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./simple.fragment\";\r\nimport \"./simple.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass SimpleMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class SimpleMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture: BaseTexture;\r\n\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SimpleMaterialDefines();\r\n        }\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.DIFFUSE = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            const shaderName = \"simple\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\"];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights - 1 },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SimpleMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                this._activeEffect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                this._activeEffect.setMatrix(\"diffuseMatrix\", this._diffuseTexture.getTextureMatrix());\r\n            }\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        // Lights\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this.diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this._diffuseTexture) {\r\n            this._diffuseTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): SimpleMaterial {\r\n        return SerializationHelper.Clone<SimpleMaterial>(() => new SimpleMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SimpleMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"SimpleMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SimpleMaterial {\r\n        return SerializationHelper.Parse(() => new SimpleMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SimpleMaterial\", SimpleMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"skyPixelShader\";\nconst shader = `precision highp float;\rvarying vec3 vPositionW;\r#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneFragmentDeclaration>\nuniform vec3 cameraPosition;\runiform vec3 cameraOffset;\runiform vec3 up;\runiform float luminance;\runiform float turbidity;\runiform float rayleigh;\runiform float mieCoefficient;\runiform float mieDirectionalG;\runiform vec3 sunPosition;\r#include<fogFragmentDeclaration>\nconst float e=2.71828182845904523536028747135266249775724709369995957;\rconst float pi=3.141592653589793238462643383279502884197169;\rconst float n=1.0003;\rconst float N=2.545E25;\rconst float pn=0.035;\rconst vec3 lambda=vec3(680E-9,550E-9,450E-9);\rconst vec3 K=vec3(0.686,0.678,0.666);\rconst float v=4.0;\rconst float rayleighZenithLength=8.4E3;\rconst float mieZenithLength=1.25E3;\rconst float EE=1000.0;\rconst float sunAngularDiameterCos=0.999956676946448443553574619906976478926848692873900859324;\rconst float cutoffAngle=pi/1.95;\rconst float steepness=1.5;\rvec3 totalRayleigh(vec3 lambda)\r{\rreturn (8.0*pow(pi,3.0)*pow(pow(n,2.0)-1.0,2.0)*(6.0+3.0*pn))/(3.0*N*pow(lambda,vec3(4.0))*(6.0-7.0*pn));\r}\rvec3 simplifiedRayleigh()\r{\rreturn 0.0005/vec3(94,40,18);\r}\rfloat rayleighPhase(float cosTheta)\r{ \rreturn (3.0/(16.0*pi))*(1.0+pow(cosTheta,2.0));\r}\rvec3 totalMie(vec3 lambda,vec3 K,float T)\r{\rfloat c=(0.2*T )*10E-18;\rreturn 0.434*c*pi*pow((2.0*pi)/lambda,vec3(v-2.0))*K;\r}\rfloat hgPhase(float cosTheta,float g)\r{\rreturn (1.0/(4.0*pi))*((1.0-pow(g,2.0))/pow(1.0-2.0*g*cosTheta+pow(g,2.0),1.5));\r}\rfloat sunIntensity(float zenithAngleCos)\r{\rreturn EE*max(0.0,1.0-exp((-(cutoffAngle-acos(zenithAngleCos))/steepness)));\r}\rfloat A=0.15;\rfloat B=0.50;\rfloat C=0.10;\rfloat D=0.20;\rfloat EEE=0.02;\rfloat F=0.30;\rfloat W=1000.0;\rvec3 Uncharted2Tonemap(vec3 x)\r{\rreturn ((x*(A*x+C*B)+D*EEE)/(x*(A*x+B)+D*F))-EEE/F;\r}\r#if DITHER\n#include<helperFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n/**\r*--------------------------------------------------------------------------------------------------\r* Sky Color\r*--------------------------------------------------------------------------------------------------\r*/\rfloat sunfade=1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);\rfloat rayleighCoefficient=rayleigh-(1.0*(1.0-sunfade));\rvec3 sunDirection=normalize(sunPosition);\rfloat sunE=sunIntensity(dot(sunDirection,up));\rvec3 betaR=simplifiedRayleigh()*rayleighCoefficient;\rvec3 betaM=totalMie(lambda,K,turbidity)*mieCoefficient;\rfloat zenithAngle=acos(max(0.0,dot(up,normalize(vPositionW-cameraPosition+cameraOffset))));\rfloat sR=rayleighZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\rfloat sM=mieZenithLength/(cos(zenithAngle)+0.15*pow(93.885-((zenithAngle*180.0)/pi),-1.253));\rvec3 Fex=exp(-(betaR*sR+betaM*sM));\rfloat cosTheta=dot(normalize(vPositionW-cameraPosition),sunDirection);\rfloat rPhase=rayleighPhase(cosTheta*0.5+0.5);\rvec3 betaRTheta=betaR*rPhase;\rfloat mPhase=hgPhase(cosTheta,mieDirectionalG);\rvec3 betaMTheta=betaM*mPhase;\rvec3 Lin=pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*(1.0-Fex),vec3(1.5));\rLin*=mix(vec3(1.0),pow(sunE*((betaRTheta+betaMTheta)/(betaR+betaM))*Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up,sunDirection),5.0),0.0,1.0));\rvec3 direction=normalize(vPositionW-cameraPosition);\rfloat theta=acos(direction.y);\rfloat phi=atan(direction.z,direction.x);\rvec2 uv=vec2(phi,theta)/vec2(2.0*pi,pi)+vec2(0.5,0.0);\rvec3 L0=vec3(0.1)*Fex;\rfloat sundisk=smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);\rL0+=(sunE*19000.0*Fex)*sundisk;\rvec3 whiteScale=1.0/Uncharted2Tonemap(vec3(W));\rvec3 texColor=(Lin+L0);\rtexColor*=0.04 ;\rtexColor+=vec3(0.0,0.001,0.0025)*0.3;\rfloat g_fMaxLuminance=1.0;\rfloat fLumScaled=0.1/luminance; \rfloat fLumCompressed=(fLumScaled*(1.0+(fLumScaled/(g_fMaxLuminance*g_fMaxLuminance))))/(1.0+fLumScaled); \rfloat ExposureBias=fLumCompressed;\rvec3 curr=Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);\rvec3 retColor=curr*whiteScale;\r/**\r*--------------------------------------------------------------------------------------------------\r* Sky Color\r*--------------------------------------------------------------------------------------------------\r*/\rfloat alpha=1.0;\r#ifdef VERTEXCOLOR\nretColor.rgb*=vColor.rgb;\r#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#if DITHER\nretColor.rgb+=dither(gl_FragCoord.xy,0.5);\r#endif\nvec4 color=clamp(vec4(retColor.rgb,alpha),0.0,1.0);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\n\nconst name = \"skyVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\nuniform mat4 world;\runiform mat4 view;\runiform mat4 viewProjection;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef VERTEXCOLOR\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\ngl_Position=viewProjection*world*vec4(position,1.0);\rvec4 worldPos=world*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#include<clipPlaneVertex>\n#include<fogVertex>\n#ifdef VERTEXCOLOR\nvColor=color;\r#endif\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const skyVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector3, serialize, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./sky.fragment\";\r\nimport \"./sky.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\n/** @internal */\r\nclass SkyMaterialDefines extends MaterialDefines {\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public DITHER = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * This is the sky material which allows to create dynamic and texture free effects for skyboxes.\r\n * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n */\r\nexport class SkyMaterial extends PushMaterial {\r\n    /**\r\n     * Defines the overall luminance of sky in interval ]0, 1[.\r\n     */\r\n    @serialize()\r\n    public luminance: number = 1.0;\r\n\r\n    /**\r\n     * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.\r\n     */\r\n    @serialize()\r\n    public turbidity: number = 10.0;\r\n\r\n    /**\r\n     * Defines the sky appearance (light intensity).\r\n     */\r\n    @serialize()\r\n    public rayleigh: number = 2.0;\r\n\r\n    /**\r\n     * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.\r\n     */\r\n    @serialize()\r\n    public mieCoefficient: number = 0.005;\r\n\r\n    /**\r\n     * Defines the amount of haze particles following the Mie scattering theory.\r\n     */\r\n    @serialize()\r\n    public mieDirectionalG: number = 0.8;\r\n\r\n    /**\r\n     * Defines the distance of the sun according to the active scene camera.\r\n     */\r\n    @serialize()\r\n    public distance: number = 500;\r\n\r\n    /**\r\n     * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said\r\n     * \"inclined\".\r\n     */\r\n    @serialize()\r\n    public inclination: number = 0.49;\r\n\r\n    /**\r\n     * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between\r\n     * an object direction and a reference direction.\r\n     */\r\n    @serialize()\r\n    public azimuth: number = 0.25;\r\n\r\n    /**\r\n     * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then\r\n     * the property is overridden by the inclination and the azimuth and can be read at any moment.\r\n     */\r\n    @serializeAsVector3()\r\n    public sunPosition: Vector3 = new Vector3(0, 100, 0);\r\n\r\n    /**\r\n     * Defines if the sun position should be computed (inclination and azimuth) according to the given\r\n     * .sunPosition property.\r\n     */\r\n    @serialize()\r\n    public useSunPosition: boolean = false;\r\n\r\n    /**\r\n     * Defines an offset vector used to get a horizon offset.\r\n     * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis\r\n     */\r\n    @serializeAsVector3()\r\n    public cameraOffset: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())\r\n     */\r\n    @serializeAsVector3()\r\n    public up: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * Defines if sky should be dithered.\r\n     */\r\n    @serialize()\r\n    public dithering: boolean = false;\r\n\r\n    // Private members\r\n    private _cameraPosition: Vector3 = Vector3.Zero();\r\n    private _skyOrientation: Quaternion = new Quaternion();\r\n\r\n    /**\r\n     * Instantiates a new sky material.\r\n     * This material allows to create dynamic and texture free\r\n     * effects for skyboxes by taking care of the atmosphere state.\r\n     * @see https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns false as the sky material doesn't need alpha testing.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns null as the sky material has no texture.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new SkyMaterialDefines();\r\n        }\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, false, defines);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, false);\r\n\r\n        if (defines.IMAGEPROCESSINGPOSTPROCESS !== scene.imageProcessingConfiguration.applyByPostProcess) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        if (defines.DITHER !== this.dithering) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n            defines.DITHER = this.dithering;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            const shaderName = \"sky\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"luminance\",\r\n                \"turbidity\",\r\n                \"rayleigh\",\r\n                \"mieCoefficient\",\r\n                \"mieDirectionalG\",\r\n                \"sunPosition\",\r\n                \"cameraPosition\",\r\n                \"cameraOffset\",\r\n                \"up\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n            const join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(shaderName, attribs, uniforms, [], join, fallbacks, this.onCompiled, this.onError), defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <SkyMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Sky\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            const cameraWorldMatrix = camera.getWorldMatrix();\r\n            this._cameraPosition.x = cameraWorldMatrix.m[12];\r\n            this._cameraPosition.y = cameraWorldMatrix.m[13];\r\n            this._cameraPosition.z = cameraWorldMatrix.m[14];\r\n            this._activeEffect.setVector3(\"cameraPosition\", this._cameraPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"cameraOffset\", this.cameraOffset);\r\n\r\n        this._activeEffect.setVector3(\"up\", this.up);\r\n\r\n        if (this.luminance > 0) {\r\n            this._activeEffect.setFloat(\"luminance\", this.luminance);\r\n        }\r\n\r\n        this._activeEffect.setFloat(\"turbidity\", this.turbidity);\r\n        this._activeEffect.setFloat(\"rayleigh\", this.rayleigh);\r\n        this._activeEffect.setFloat(\"mieCoefficient\", this.mieCoefficient);\r\n        this._activeEffect.setFloat(\"mieDirectionalG\", this.mieDirectionalG);\r\n\r\n        if (!this.useSunPosition) {\r\n            const theta = Math.PI * (this.inclination - 0.5);\r\n            const phi = 2 * Math.PI * (this.azimuth - 0.5);\r\n\r\n            this.sunPosition.x = this.distance * Math.cos(phi) * Math.cos(theta);\r\n            this.sunPosition.y = this.distance * Math.sin(-theta);\r\n            this.sunPosition.z = this.distance * Math.sin(phi) * Math.cos(theta);\r\n\r\n            Quaternion.FromUnitVectorsToRef(Vector3.UpReadOnly, this.up, this._skyOrientation);\r\n            this.sunPosition.rotateByQuaternionToRef(this._skyOrientation, this.sunPosition);\r\n        }\r\n\r\n        this._activeEffect.setVector3(\"sunPosition\", this.sunPosition);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): SkyMaterial {\r\n        return SerializationHelper.Clone<SkyMaterial>(() => new SkyMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.SkyMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"SkyMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SkyMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Creates a sky material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new sky material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): SkyMaterial {\r\n        return SerializationHelper.Parse(() => new SkyMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SkyMaterial\", SkyMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"terrainPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;\runiform sampler2D textureSampler;\runiform vec2 vTextureInfos;\runiform sampler2D diffuse1Sampler;\runiform sampler2D diffuse2Sampler;\runiform sampler2D diffuse3Sampler;\runiform vec2 diffuse1Infos;\runiform vec2 diffuse2Infos;\runiform vec2 diffuse3Infos;\r#endif\n#ifdef BUMP\nuniform sampler2D bump1Sampler;\runiform sampler2D bump2Sampler;\runiform sampler2D bump3Sampler;\r#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\r{\rvec3 dp1=dFdx(p);\rvec3 dp2=dFdy(p);\rvec2 duv1=dFdx(uv);\rvec2 duv2=dFdy(uv);\rvec3 dp2perp=cross(dp2,normal);\rvec3 dp1perp=cross(normal,dp1);\rvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\rvec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\rfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\rreturn mat3(tangent*invmax,binormal*invmax,normal);\r}\rvec3 perturbNormal(vec3 viewDir,vec3 mixColor)\r{\rvec3 bump1Color=texture2D(bump1Sampler,vTextureUV*diffuse1Infos).xyz;\rvec3 bump2Color=texture2D(bump2Sampler,vTextureUV*diffuse2Infos).xyz;\rvec3 bump3Color=texture2D(bump3Sampler,vTextureUV*diffuse3Infos).xyz;\rbump1Color.rgb*=mixColor.r;\rbump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);\rvec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);\rmap=map*255./127.-128./127.;\rmat3 TBN=cotangent_frame(vNormalW*vTextureInfos.y,-viewDir,vTextureUV);\rreturn normalize(TBN*map);\r}\r#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\nfloat alpha=vDiffuseColor.a;\r#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(textureSampler,vTextureUV);\r#if defined(BUMP) && defined(DIFFUSE)\nnormalW=perturbNormal(viewDirectionW,baseColor.rgb);\r#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\nbaseColor.rgb*=vTextureInfos.y;\rvec4 diffuse1Color=texture2D(diffuse1Sampler,vTextureUV*diffuse1Infos);\rvec4 diffuse2Color=texture2D(diffuse2Sampler,vTextureUV*diffuse2Infos);\rvec4 diffuse3Color=texture2D(diffuse3Sampler,vTextureUV*diffuse3Infos);\rdiffuse1Color.rgb*=baseColor.r;\rdiffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);\rbaseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor*baseColor.rgb,0.0,1.0);\rvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const terrainPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"terrainVertexShader\";\nconst shader = `precision highp float;attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;uniform mat4 viewProjection;\n#ifdef DIFFUSE\nvarying vec2 vTextureUV;uniform mat4 textureMatrix;uniform vec2 vTextureInfos;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\n#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\n#endif\n#ifdef DIFFUSE\nif (vTextureInfos.x==0.)\n{vTextureUV=vec2(textureMatrix*vec4(uv,1.0,0.0));}\nelse\n{vTextureUV=vec2(textureMatrix*vec4(uv2,1.0,0.0));}\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const terrainVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./terrain.fragment\";\r\nimport \"./terrain.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass TerrainMaterialDefines extends MaterialDefines {\r\n    public DIFFUSE = false;\r\n    public BUMP = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TerrainMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"mixTexture\")\r\n    private _mixTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture1\")\r\n    private _diffuseTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture2\")\r\n    private _diffuseTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"diffuseTexture3\")\r\n    private _diffuseTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTexture3: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture1\")\r\n    private _bumpTexture1: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture1: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture2\")\r\n    private _bumpTexture2: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture2: Texture;\r\n\r\n    @serializeAsTexture(\"bumpTexture3\")\r\n    private _bumpTexture3: Texture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture3: Texture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TerrainMaterialDefines();\r\n        }\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (!this.mixTexture || !this.mixTexture.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            defines._needUVs = true;\r\n\r\n            if (MaterialFlags.DiffuseTextureEnabled) {\r\n                if (!this.diffuseTexture1 || !this.diffuseTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture2 || !this.diffuseTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.diffuseTexture3 || !this.diffuseTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines.DIFFUSE = true;\r\n            }\r\n\r\n            if (this.bumpTexture1 && this.bumpTexture2 && this.bumpTexture3 && MaterialFlags.BumpTextureEnabled) {\r\n                if (!this.bumpTexture1.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture2.isReady()) {\r\n                    return false;\r\n                }\r\n                if (!this.bumpTexture3.isReady()) {\r\n                    return false;\r\n                }\r\n\r\n                defines._needNormals = true;\r\n                defines.BUMP = true;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"terrain\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vTextureInfos\",\r\n                \"mBones\",\r\n                \"textureMatrix\",\r\n                \"diffuse1Infos\",\r\n                \"diffuse2Infos\",\r\n                \"diffuse3Infos\",\r\n            ];\r\n            const samplers = [\"textureSampler\", \"diffuse1Sampler\", \"diffuse2Sampler\", \"diffuse3Sampler\", \"bump1Sampler\", \"bump2Sampler\", \"bump3Sampler\"];\r\n\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TerrainMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.mixTexture) {\r\n                this._activeEffect.setTexture(\"textureSampler\", this._mixTexture);\r\n                this._activeEffect.setFloat2(\"vTextureInfos\", this._mixTexture.coordinatesIndex, this._mixTexture.level);\r\n                this._activeEffect.setMatrix(\"textureMatrix\", this._mixTexture.getTextureMatrix());\r\n\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    if (this._diffuseTexture1) {\r\n                        this._activeEffect.setTexture(\"diffuse1Sampler\", this._diffuseTexture1);\r\n                        this._activeEffect.setFloat2(\"diffuse1Infos\", this._diffuseTexture1.uScale, this._diffuseTexture1.vScale);\r\n                    }\r\n                    if (this._diffuseTexture2) {\r\n                        this._activeEffect.setTexture(\"diffuse2Sampler\", this._diffuseTexture2);\r\n                        this._activeEffect.setFloat2(\"diffuse2Infos\", this._diffuseTexture2.uScale, this._diffuseTexture2.vScale);\r\n                    }\r\n                    if (this._diffuseTexture3) {\r\n                        this._activeEffect.setTexture(\"diffuse3Sampler\", this._diffuseTexture3);\r\n                        this._activeEffect.setFloat2(\"diffuse3Infos\", this._diffuseTexture3.uScale, this._diffuseTexture3.vScale);\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.BumpTextureEnabled && scene.getEngine().getCaps().standardDerivatives) {\r\n                    if (this._bumpTexture1) {\r\n                        this._activeEffect.setTexture(\"bump1Sampler\", this._bumpTexture1);\r\n                    }\r\n                    if (this._bumpTexture2) {\r\n                        this._activeEffect.setTexture(\"bump2Sampler\", this._bumpTexture2);\r\n                    }\r\n                    if (this._bumpTexture3) {\r\n                        this._activeEffect.setTexture(\"bump3Sampler\", this._bumpTexture3);\r\n                    }\r\n                }\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._mixTexture) {\r\n            activeTextures.push(this._mixTexture);\r\n        }\r\n\r\n        if (this._diffuseTexture1) {\r\n            activeTextures.push(this._diffuseTexture1);\r\n        }\r\n\r\n        if (this._diffuseTexture2) {\r\n            activeTextures.push(this._diffuseTexture2);\r\n        }\r\n\r\n        if (this._diffuseTexture3) {\r\n            activeTextures.push(this._diffuseTexture3);\r\n        }\r\n\r\n        if (this._bumpTexture1) {\r\n            activeTextures.push(this._bumpTexture1);\r\n        }\r\n\r\n        if (this._bumpTexture2) {\r\n            activeTextures.push(this._bumpTexture2);\r\n        }\r\n\r\n        if (this._bumpTexture3) {\r\n            activeTextures.push(this._bumpTexture3);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._mixTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture1 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture2 === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture3 === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TerrainMaterial {\r\n        return SerializationHelper.Clone(() => new TerrainMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TerrainMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TerrainMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TerrainMaterial {\r\n        return SerializationHelper.Parse(() => new TerrainMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TerrainMaterial\", TerrainMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/depthPrePass\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\nimport \"core/Shaders/ShadersInclude/imageProcessingCompatibility\";\n\nconst name = \"triplanarPixelShader\";\nconst shader = `precision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\runiform sampler2D diffuseSamplerX;\r#ifdef BUMPX\nuniform sampler2D normalSamplerX;\r#endif\n#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\runiform sampler2D diffuseSamplerY;\r#ifdef BUMPY\nuniform sampler2D normalSamplerY;\r#endif\n#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\runiform sampler2D diffuseSamplerZ;\r#ifdef BUMPZ\nuniform sampler2D normalSamplerZ;\r#endif\n#endif\n#ifdef NORMAL\nvarying mat3 tangentSpace;\r#endif\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(0.,0.,0.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef NORMAL\nvec3 normalW=tangentSpace[2];\r#else\nvec3 normalW=vec3(1.0,1.0,1.0);\r#endif\nvec4 baseNormal=vec4(0.0,0.0,0.0,1.0);\rnormalW*=normalW;\r#ifdef DIFFUSEX\nbaseColor+=texture2D(diffuseSamplerX,vTextureUVX)*normalW.x;\r#ifdef BUMPX\nbaseNormal+=texture2D(normalSamplerX,vTextureUVX)*normalW.x;\r#endif\n#endif\n#ifdef DIFFUSEY\nbaseColor+=texture2D(diffuseSamplerY,vTextureUVY)*normalW.y;\r#ifdef BUMPY\nbaseNormal+=texture2D(normalSamplerY,vTextureUVY)*normalW.y;\r#endif\n#endif\n#ifdef DIFFUSEZ\nbaseColor+=texture2D(diffuseSamplerZ,vTextureUVZ)*normalW.z;\r#ifdef BUMPZ\nbaseNormal+=texture2D(normalSamplerZ,vTextureUVZ)*normalW.z;\r#endif\n#endif\n#ifdef NORMAL\nnormalW=normalize((2.0*baseNormal.xyz-1.0)*tangentSpace);\r#endif\n#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;\rvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<fogFragment>\ngl_FragColor=color;\r#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const triplanarPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\n\nconst name = \"triplanarVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef DIFFUSEX\nvarying vec2 vTextureUVX;\r#endif\n#ifdef DIFFUSEY\nvarying vec2 vTextureUVY;\r#endif\n#ifdef DIFFUSEZ\nvarying vec2 vTextureUVZ;\r#endif\nuniform float tileSize;\r#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying mat3 tangentSpace;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\r{\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rgl_Position=viewProjection*worldPos;\rvPositionW=vec3(worldPos);\r#ifdef DIFFUSEX\nvTextureUVX=worldPos.zy/tileSize;\r#endif\n#ifdef DIFFUSEY\nvTextureUVY=worldPos.xz/tileSize;\r#endif\n#ifdef DIFFUSEZ\nvTextureUVZ=worldPos.xy/tileSize;\r#endif\n#ifdef NORMAL\nvec3 xtan=vec3(0,0,1);\rvec3 xbin=vec3(0,1,0);\rvec3 ytan=vec3(1,0,0);\rvec3 ybin=vec3(0,0,1);\rvec3 ztan=vec3(1,0,0);\rvec3 zbin=vec3(0,1,0);\rvec3 normalizedNormal=normalize(normal);\rnormalizedNormal*=normalizedNormal;\rvec3 worldBinormal=normalize(xbin*normalizedNormal.x+ybin*normalizedNormal.y+zbin*normalizedNormal.z);\rvec3 worldTangent=normalize(xtan*normalizedNormal.x+ytan*normalizedNormal.y+ztan*normalizedNormal.z);\rworldTangent=(world*vec4(worldTangent,0.0)).xyz;\rworldBinormal=(world*vec4(worldBinormal,0.0)).xyz;\rvec3 worldNormal=(world*vec4(normalize(normal),0.0)).xyz;\rtangentSpace[0]=worldTangent;\rtangentSpace[1]=worldBinormal;\rtangentSpace[2]=worldNormal;\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const triplanarVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./triplanar.fragment\";\r\nimport \"./triplanar.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass TriPlanarMaterialDefines extends MaterialDefines {\r\n    public DIFFUSEX = false;\r\n    public DIFFUSEY = false;\r\n    public DIFFUSEZ = false;\r\n\r\n    public BUMPX = false;\r\n    public BUMPY = false;\r\n    public BUMPZ = false;\r\n\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public NORMAL = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class TriPlanarMaterial extends PushMaterial {\r\n    @serializeAsTexture()\r\n    public mixTexture: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureX\")\r\n    private _diffuseTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTexturY\")\r\n    private _diffuseTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"diffuseTextureZ\")\r\n    private _diffuseTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public diffuseTextureZ: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureX\")\r\n    private _normalTextureX: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureX: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureY\")\r\n    private _normalTextureY: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureY: BaseTexture;\r\n\r\n    @serializeAsTexture(\"normalTextureZ\")\r\n    private _normalTextureZ: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalTextureZ: BaseTexture;\r\n\r\n    @serialize()\r\n    public tileSize: number = 1;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0.2, 0.2, 0.2);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    // Methods\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new TriPlanarMaterialDefines();\r\n        }\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (MaterialFlags.DiffuseTextureEnabled) {\r\n                    const textures = [this.diffuseTextureX, this.diffuseTextureY, this.diffuseTextureZ];\r\n                    const textureDefines = [\"DIFFUSEX\", \"DIFFUSEY\", \"DIFFUSEZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (MaterialFlags.BumpTextureEnabled) {\r\n                    const textures = [this.normalTextureX, this.normalTextureY, this.normalTextureZ];\r\n                    const textureDefines = [\"BUMPX\", \"BUMPY\", \"BUMPZ\"];\r\n\r\n                    for (let i = 0; i < textures.length; i++) {\r\n                        if (textures[i]) {\r\n                            if (!textures[i].isReady()) {\r\n                                return false;\r\n                            } else {\r\n                                (<any>defines)[textureDefines[i]] = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Values that need to be evaluated on every frame\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"triplanar\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"mBones\",\r\n                \"tileSize\",\r\n            ];\r\n            const samplers = [\"diffuseSamplerX\", \"diffuseSamplerY\", \"diffuseSamplerZ\", \"normalSamplerX\", \"normalSamplerY\", \"normalSamplerZ\"];\r\n\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <TriPlanarMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        this._activeEffect.setFloat(\"tileSize\", this.tileSize);\r\n\r\n        if (scene.getCachedMaterial() !== this) {\r\n            // Textures\r\n            if (this.diffuseTextureX) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerX\", this.diffuseTextureX);\r\n            }\r\n            if (this.diffuseTextureY) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerY\", this.diffuseTextureY);\r\n            }\r\n            if (this.diffuseTextureZ) {\r\n                this._activeEffect.setTexture(\"diffuseSamplerZ\", this.diffuseTextureZ);\r\n            }\r\n            if (this.normalTextureX) {\r\n                this._activeEffect.setTexture(\"normalSamplerX\", this.normalTextureX);\r\n            }\r\n            if (this.normalTextureY) {\r\n                this._activeEffect.setTexture(\"normalSamplerY\", this.normalTextureY);\r\n            }\r\n            if (this.normalTextureZ) {\r\n                this._activeEffect.setTexture(\"normalSamplerZ\", this.normalTextureZ);\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.mixTexture && this.mixTexture.animations && this.mixTexture.animations.length > 0) {\r\n            results.push(this.mixTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTextureX) {\r\n            activeTextures.push(this._diffuseTextureX);\r\n        }\r\n\r\n        if (this._diffuseTextureY) {\r\n            activeTextures.push(this._diffuseTextureY);\r\n        }\r\n\r\n        if (this._diffuseTextureZ) {\r\n            activeTextures.push(this._diffuseTextureZ);\r\n        }\r\n\r\n        if (this._normalTextureX) {\r\n            activeTextures.push(this._normalTextureX);\r\n        }\r\n\r\n        if (this._normalTextureY) {\r\n            activeTextures.push(this._normalTextureY);\r\n        }\r\n\r\n        if (this._normalTextureZ) {\r\n            activeTextures.push(this._normalTextureZ);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTextureZ === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureX === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureY === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._normalTextureZ === texture) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.mixTexture) {\r\n            this.mixTexture.dispose();\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): TriPlanarMaterial {\r\n        return SerializationHelper.Clone(() => new TriPlanarMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.TriPlanarMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"TriPlanarMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): TriPlanarMaterial {\r\n        return SerializationHelper.Parse(() => new TriPlanarMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarMaterial\", TriPlanarMaterial);\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"core/Shaders/ShadersInclude/imageProcessingDeclaration\";\nimport \"core/Shaders/ShadersInclude/imageProcessingFunctions\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/shadowsFragmentFunctions\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneFragment\";\nimport \"core/Shaders/ShadersInclude/lightFragment\";\nimport \"core/Shaders/ShadersInclude/logDepthFragment\";\nimport \"core/Shaders/ShadersInclude/fogFragment\";\n\nconst name = \"waterPixelShader\";\nconst shader = `#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\runiform vec4 vEyePosition;\runiform vec4 vDiffuseColor;\r#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<helperFunctions>\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#ifdef BUMP\nvarying vec2 vNormalUV;\r#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\r#endif\nuniform sampler2D normalSampler;\runiform vec2 vNormalInfos;\r#endif\nuniform sampler2D refractionSampler;\runiform sampler2D reflectionSampler;\rconst float LOG2=1.442695;\runiform vec3 cameraPosition;\runiform vec4 waterColor;\runiform float colorBlendFactor;\runiform vec4 waterColor2;\runiform float colorBlendFactor2;\runiform float bumpHeight;\runiform float time;\rvarying vec3 vRefractionMapTexCoord;\rvarying vec3 vReflectionMapTexCoord;\rvarying vec3 vPosition;\r#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\rvec4 baseColor=vec4(1.,1.,1.,1.);\rvec3 diffuseColor=vDiffuseColor.rgb;\rfloat alpha=vDiffuseColor.a;\r#ifdef BUMP\n#ifdef BUMPSUPERIMPOSE\nbaseColor=0.6*texture2D(normalSampler,vNormalUV)+0.4*texture2D(normalSampler,vec2(vNormalUV2.x,vNormalUV2.y));\r#else\nbaseColor=texture2D(normalSampler,vNormalUV);\r#endif\nvec3 bumpColor=baseColor.rgb;\r#ifdef ALPHATEST\nif (baseColor.a<0.4)\rdiscard;\r#endif\nbaseColor.rgb*=vNormalInfos.y;\r#else\nvec3 bumpColor=vec3(1.0);\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\r#endif\n#ifdef NORMAL\nvec2 perturbation=bumpHeight*(baseColor.rg-0.5);\r#ifdef BUMPAFFECTSREFLECTION\nvec3 normalW=normalize(vNormalW+vec3(perturbation.x*8.0,0.0,perturbation.y*8.0));\rif (normalW.y<0.0) {\rnormalW.y=-normalW.y;\r}\r#else\nvec3 normalW=normalize(vNormalW);\r#endif\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\rvec2 perturbation=bumpHeight*(vec2(1.0,1.0)-0.5);\r#endif\n#ifdef FRESNELSEPARATE\n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation*0.5,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vec2(\rvReflectionMapTexCoord.x/vReflectionMapTexCoord.z+perturbation.x*0.3,\rvReflectionMapTexCoord.y/vReflectionMapTexCoord.z+perturbation.y\r),0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=clamp(abs(pow(dot(viewDirectionW,upVector),3.0)),0.05,0.65);\rfloat IfresnelTerm=1.0-fresnelTerm;\rrefractiveColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*refractiveColor;\rreflectiveColor=IfresnelTerm*colorBlendFactor2*waterColor+(1.0-colorBlendFactor2*IfresnelTerm)*reflectiveColor;\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*IfresnelTerm;\rbaseColor=combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#else \n#ifdef REFLECTION\nvec2 projectedRefractionTexCoords=clamp(vRefractionMapTexCoord.xy/vRefractionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 refractiveColor=texture2D(refractionSampler,projectedRefractionTexCoords);\r#ifdef IS_REFRACTION_LINEAR\nrefractiveColor.rgb=toGammaSpace(refractiveColor.rgb);\r#endif\nvec2 projectedReflectionTexCoords=clamp(vReflectionMapTexCoord.xy/vReflectionMapTexCoord.z+perturbation,0.0,1.0);\rvec4 reflectiveColor=texture2D(reflectionSampler,projectedReflectionTexCoords);\r#ifdef IS_REFLECTION_LINEAR\nreflectiveColor.rgb=toGammaSpace(reflectiveColor.rgb);\r#endif\nvec3 upVector=vec3(0.0,1.0,0.0);\rfloat fresnelTerm=max(dot(viewDirectionW,upVector),0.0);\rvec4 combinedColor=refractiveColor*fresnelTerm+reflectiveColor*(1.0-fresnelTerm);\rbaseColor=colorBlendFactor*waterColor+(1.0-colorBlendFactor)*combinedColor;\r#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\rlightingInfo info;\rfloat shadow=1.;\r#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\rvec3 specularBase=vec3(0.,0.,0.);\rvec3 specularColor=vSpecularColor.rgb;\r#else\nfloat glossiness=0.;\r#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec3 finalDiffuse=clamp(baseColor.rgb,0.0,1.0);\r#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\r#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\r#else\nvec3 finalSpecular=vec3(0.0);\r#endif\n#endif\nvec4 color=vec4(finalDiffuse+finalSpecular,alpha);\r#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\r#elif defined(IMAGEPROCESSING)\ncolor.rgb=toLinearSpace(color.rgb);\rcolor=applyImageProcessing(color);\r#endif\ngl_FragColor=color;\r#define CUSTOM_FRAGMENT_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/bonesDeclaration\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesDeclaration\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/fogVertexDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightFragmentDeclaration\";\nimport \"core/Shaders/ShadersInclude/lightUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/logDepthDeclaration\";\nimport \"core/Shaders/ShadersInclude/instancesVertex\";\nimport \"core/Shaders/ShadersInclude/bonesVertex\";\nimport \"core/Shaders/ShadersInclude/bakedVertexAnimation\";\nimport \"core/Shaders/ShadersInclude/clipPlaneVertex\";\nimport \"core/Shaders/ShadersInclude/fogVertex\";\nimport \"core/Shaders/ShadersInclude/shadowsVertex\";\nimport \"core/Shaders/ShadersInclude/vertexColorMixing\";\nimport \"core/Shaders/ShadersInclude/logDepthVertex\";\n\nconst name = \"waterVertexShader\";\nconst shader = `precision highp float;\rattribute vec3 position;\r#ifdef NORMAL\nattribute vec3 normal;\r#endif\n#ifdef UV1\nattribute vec2 uv;\r#endif\n#ifdef UV2\nattribute vec2 uv2;\r#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\r#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\runiform mat4 viewProjection;\r#ifdef BUMP\nvarying vec2 vNormalUV;\r#ifdef BUMPSUPERIMPOSE\nvarying vec2 vNormalUV2;\r#endif\nuniform mat4 normalMatrix;\runiform vec2 vNormalInfos;\r#endif\n#ifdef POINTSIZE\nuniform float pointSize;\r#endif\nvarying vec3 vPositionW;\r#ifdef NORMAL\nvarying vec3 vNormalW;\r#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\r#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<logDepthDeclaration>\nuniform mat4 worldReflectionViewProjection;\runiform vec2 windDirection;\runiform float waveLength;\runiform float time;\runiform float windForce;\runiform float waveHeight;\runiform float waveSpeed;\runiform float waveCount;\rvarying vec3 vPosition;\rvarying vec3 vRefractionMapTexCoord;\rvarying vec3 vReflectionMapTexCoord;\r#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\r#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\rvPositionW=vec3(worldPos);\r#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\r#endif\n#ifndef UV1\nvec2 uv=vec2(0.,0.);\r#endif\n#ifndef UV2\nvec2 uv2=vec2(0.,0.);\r#endif\n#ifdef BUMP\nif (vNormalInfos.x==0.)\r{\rvNormalUV=vec2(normalMatrix*vec4((uv*1.0)/waveLength+time*windForce*windDirection,1.0,0.0));\r#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv*0.721)/waveLength+time*1.2*windForce*windDirection,1.0,0.0));\r#endif\n}\relse\r{\rvNormalUV=vec2(normalMatrix*vec4((uv2*1.0)/waveLength+time*windForce*windDirection ,1.0,0.0));\r#ifdef BUMPSUPERIMPOSE\nvNormalUV2=vec2(normalMatrix*vec4((uv2*0.721)/waveLength+time*1.2*windForce*windDirection ,1.0,0.0));\r#endif\n}\r#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\r#endif\nfloat finalWaveCount=1.0/(waveCount*0.5);\rvec3 p=position;\rfloat newY=(sin(((p.x/finalWaveCount)+time*waveSpeed))*waveHeight*windDirection.x*5.0)\r+ (cos(((p.z/finalWaveCount)+ time*waveSpeed))*waveHeight*windDirection.y*5.0);\rp.y+=abs(newY);\rgl_Position=viewProjection*finalWorld*vec4(p,1.0);\r#ifdef REFLECTION\nworldPos=viewProjection*finalWorld*vec4(p,1.0);\rvPosition=position;\rvRefractionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\rvRefractionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\rvRefractionMapTexCoord.z=worldPos.w;\rworldPos=worldReflectionViewProjection*vec4(position,1.0);\rvReflectionMapTexCoord.x=0.5*(worldPos.w+worldPos.x);\rvReflectionMapTexCoord.y=0.5*(worldPos.w+worldPos.y);\rvReflectionMapTexCoord.z=worldPos.w;\r#endif\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const waterVertexShader = { name, shader };\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { serializeAsVector2, serializeAsTexture, serialize, expandToProperty, serializeAsColor3, SerializationHelper } from \"core/Misc/decorators\";\r\nimport { Matrix, Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Plane } from \"core/Maths/math.plane\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { SmartArray } from \"core/Misc/smartArray\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport type { IImageProcessingConfigurationDefines } from \"core/Materials/imageProcessingConfiguration\";\r\nimport { ImageProcessingConfiguration } from \"core/Materials/imageProcessingConfiguration\";\r\nimport { MaterialHelper } from \"core/Materials/materialHelper\";\r\nimport { PushMaterial } from \"core/Materials/pushMaterial\";\r\nimport { MaterialFlags } from \"core/Materials/materialFlags\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Scene } from \"core/scene\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\n\r\nimport \"./water.fragment\";\r\nimport \"./water.vertex\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport { CreateGround } from \"core/Meshes/Builders/groundBuilder\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\nclass WaterMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public BUMP = false;\r\n    public REFLECTION = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public NORMAL = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public SPECULARTERM = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public USE_REVERSE_DEPTHBUFFER = false;\r\n    public FRESNELSEPARATE = false;\r\n    public BUMPSUPERIMPOSE = false;\r\n    public BUMPAFFECTSREFLECTION = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\nexport class WaterMaterial extends PushMaterial {\r\n    /*\r\n     * Public members\r\n     */\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: BaseTexture;\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: BaseTexture;\r\n\r\n    @serializeAsColor3()\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    @serializeAsColor3()\r\n    public specularColor = new Color3(0, 0, 0);\r\n\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    /**\r\n     * Defines the wind force.\r\n     */\r\n    @serialize()\r\n    public windForce: number = 6;\r\n    /**\r\n     * Defines the direction of the wind in the plane (X, Z).\r\n     */\r\n    @serializeAsVector2()\r\n    public windDirection: Vector2 = new Vector2(0, 1);\r\n    /**\r\n     * Defines the height of the waves.\r\n     */\r\n    @serialize()\r\n    public waveHeight: number = 0.4;\r\n    /**\r\n     * Defines the bump height related to the bump map.\r\n     */\r\n    @serialize()\r\n    public bumpHeight: number = 0.4;\r\n    /**\r\n     * Defines wether or not: to add a smaller moving bump to less steady waves.\r\n     */\r\n    @serialize(\"bumpSuperimpose\")\r\n    private _bumpSuperimpose = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpSuperimpose: boolean;\r\n\r\n    /**\r\n     * Defines wether or not color refraction and reflection differently with .waterColor2 and .colorBlendFactor2. Non-linear (physically correct) fresnel.\r\n     */\r\n    @serialize(\"fresnelSeparate\")\r\n    private _fresnelSeparate = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public fresnelSeparate: boolean;\r\n\r\n    /**\r\n     * Defines wether or not bump Wwves modify the reflection.\r\n     */\r\n    @serialize(\"bumpAffectsReflection\")\r\n    private _bumpAffectsReflection = false;\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public bumpAffectsReflection: boolean;\r\n\r\n    /**\r\n     * Defines the water color blended with the refraction (near).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color.\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor: number = 0.2;\r\n    /**\r\n     * Defines the water color blended with the reflection (far).\r\n     */\r\n    @serializeAsColor3()\r\n    public waterColor2: Color3 = new Color3(0.1, 0.1, 0.6);\r\n    /**\r\n     * Defines the blend factor related to the water color (reflection, far).\r\n     */\r\n    @serialize()\r\n    public colorBlendFactor2: number = 0.2;\r\n    /**\r\n     * Defines the maximum length of a wave.\r\n     */\r\n    @serialize()\r\n    public waveLength: number = 0.1;\r\n\r\n    /**\r\n     * Defines the waves speed.\r\n     */\r\n    @serialize()\r\n    public waveSpeed: number = 1.0;\r\n\r\n    /**\r\n     * Defines the number of times waves are repeated. This is typically used to adjust waves count according to the ground's size where the material is applied on.\r\n     */\r\n    @serialize()\r\n    public waveCount: number = 20;\r\n    /**\r\n     * Sets or gets whether or not automatic clipping should be enabled or not. Setting to true will save performances and\r\n     * will avoid calculating useless pixels in the pixel shader of the water material.\r\n     */\r\n    @serialize()\r\n    public disableClipPlane: boolean = false;\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /*\r\n     * Private members\r\n     */\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    private _refractionRTT: Nullable<RenderTargetTexture>;\r\n    private _reflectionRTT: Nullable<RenderTargetTexture>;\r\n\r\n    private _reflectionTransform: Matrix = Matrix.Zero();\r\n    private _lastTime: number = 0;\r\n    private _lastDeltaTime: number = 0;\r\n\r\n    private _useLogarithmicDepth: boolean;\r\n\r\n    private _waitingRenderList: Nullable<string[]>;\r\n\r\n    private _imageProcessingConfiguration: Nullable<ImageProcessingConfiguration>;\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param name\r\n     * @param scene\r\n     * @param renderTargetSize\r\n     */\r\n    constructor(name: string, scene?: Scene, public renderTargetSize: Vector2 = new Vector2(512, 512)) {\r\n        super(name, scene);\r\n\r\n        this._createRenderTargets(this.getScene(), renderTargetSize);\r\n\r\n        // Create render targets\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n            this._renderTargets.push(<RenderTargetTexture>this._reflectionRTT);\r\n            this._renderTargets.push(<RenderTargetTexture>this._refractionRTT);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    // Get / Set\r\n    public get refractionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._refractionRTT;\r\n    }\r\n\r\n    public get reflectionTexture(): Nullable<RenderTargetTexture> {\r\n        return this._reflectionRTT;\r\n    }\r\n\r\n    // Methods\r\n    public addToRenderList(node: any): void {\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            this._refractionRTT.renderList.push(node);\r\n        }\r\n\r\n        if (this._reflectionRTT && this._reflectionRTT.renderList) {\r\n            this._reflectionRTT.renderList.push(node);\r\n        }\r\n    }\r\n\r\n    public enableRenderTargets(enable: boolean): void {\r\n        const refreshRate = enable ? 1 : 0;\r\n\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.refreshRate = refreshRate;\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.refreshRate = refreshRate;\r\n        }\r\n    }\r\n\r\n    public getRenderList(): Nullable<AbstractMesh[]> {\r\n        return this._refractionRTT ? this._refractionRTT.renderList : [];\r\n    }\r\n\r\n    public get renderTargetsEnabled(): boolean {\r\n        return !(this._refractionRTT && this._refractionRTT.refreshRate === 0);\r\n    }\r\n\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    public needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (this.isFrozen) {\r\n            if (subMesh.effect && subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new WaterMaterialDefines();\r\n        }\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                    if (!this.bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.BUMP = true;\r\n                    }\r\n                }\r\n\r\n                if (MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.REFLECTION = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false);\r\n\r\n        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);\r\n\r\n        if (defines._areMiscDirty) {\r\n            if (this._fresnelSeparate) {\r\n                defines.FRESNELSEPARATE = true;\r\n            }\r\n\r\n            if (this._bumpSuperimpose) {\r\n                defines.BUMPSUPERIMPOSE = true;\r\n            }\r\n\r\n            if (this._bumpAffectsReflection) {\r\n                defines.BUMPAFFECTSREFLECTION = true;\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Image processing\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\r\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\r\n        }\r\n\r\n        // Attribs\r\n        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true);\r\n\r\n        // Configure this\r\n        this._mesh = mesh;\r\n\r\n        if (this._waitingRenderList) {\r\n            for (let i = 0; i < this._waitingRenderList.length; i++) {\r\n                this.addToRenderList(scene.getNodeById(this._waitingRenderList[i]));\r\n            }\r\n\r\n            this._waitingRenderList = null;\r\n        }\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this.maxSimultaneousLights);\r\n\r\n            if (defines.NUM_BONE_INFLUENCERS > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.UV1) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (defines.UV2) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            MaterialHelper.PrepareAttributesForInstances(attribs, defines);\r\n\r\n            // Legacy browser patch\r\n            const shaderName = \"water\";\r\n            const join = defines.toString();\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vNormalInfos\",\r\n                \"mBones\",\r\n                \"normalMatrix\",\r\n                \"logarithmicDepthConstant\",\r\n\r\n                // Water\r\n                \"worldReflectionViewProjection\",\r\n                \"windDirection\",\r\n                \"waveLength\",\r\n                \"time\",\r\n                \"windForce\",\r\n                \"cameraPosition\",\r\n                \"bumpHeight\",\r\n                \"waveHeight\",\r\n                \"waterColor\",\r\n                \"waterColor2\",\r\n                \"colorBlendFactor\",\r\n                \"colorBlendFactor2\",\r\n                \"waveSpeed\",\r\n                \"waveCount\",\r\n            ];\r\n            const samplers = [\r\n                \"normalSampler\",\r\n                // Water\r\n                \"refractionSampler\",\r\n                \"reflectionSampler\",\r\n            ];\r\n            const uniformBuffers = new Array<string>();\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            MaterialHelper.PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this.maxSimultaneousLights,\r\n            });\r\n            subMesh.setEffect(\r\n                scene.getEngine().createEffect(\r\n                    shaderName,\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: uniformBuffers,\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: this.onCompiled,\r\n                        onError: this.onError,\r\n                        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights },\r\n                    },\r\n                    engine\r\n                ),\r\n                defines,\r\n                this._materialContext\r\n            );\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        return true;\r\n    }\r\n\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <WaterMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect || !this._mesh) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\r\n\r\n        if (this._mustRebind(scene, effect)) {\r\n            // Textures\r\n            if (this.bumpTexture && MaterialFlags.BumpTextureEnabled) {\r\n                this._activeEffect.setTexture(\"normalSampler\", this.bumpTexture);\r\n\r\n                this._activeEffect.setFloat2(\"vNormalInfos\", this.bumpTexture.coordinatesIndex, this.bumpTexture.level);\r\n                this._activeEffect.setMatrix(\"normalMatrix\", this.bumpTexture.getTextureMatrix());\r\n            }\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Point size\r\n            if (this.pointsCloud) {\r\n                this._activeEffect.setFloat(\"pointSize\", this.pointSize);\r\n            }\r\n\r\n            scene.bindEyePosition(effect);\r\n        }\r\n\r\n        this._activeEffect.setColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            this._activeEffect.setColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n        }\r\n\r\n        if (scene.lightsEnabled && !this.disableLighting) {\r\n            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this.maxSimultaneousLights);\r\n        }\r\n\r\n        // View\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n\r\n        // Fog\r\n        MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\r\n\r\n        // Log. depth\r\n        MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\r\n\r\n        // Water\r\n        if (MaterialFlags.ReflectionTextureEnabled) {\r\n            this._activeEffect.setTexture(\"refractionSampler\", this._refractionRTT);\r\n            this._activeEffect.setTexture(\"reflectionSampler\", this._reflectionRTT);\r\n        }\r\n\r\n        const wrvp = this._mesh.getWorldMatrix().multiply(this._reflectionTransform).multiply(scene.getProjectionMatrix());\r\n\r\n        // Add delta time. Prevent adding delta time if it hasn't changed.\r\n        const deltaTime = scene.getEngine().getDeltaTime();\r\n        if (deltaTime !== this._lastDeltaTime) {\r\n            this._lastDeltaTime = deltaTime;\r\n            this._lastTime += this._lastDeltaTime;\r\n        }\r\n\r\n        this._activeEffect.setMatrix(\"worldReflectionViewProjection\", wrvp);\r\n        this._activeEffect.setVector2(\"windDirection\", this.windDirection);\r\n        this._activeEffect.setFloat(\"waveLength\", this.waveLength);\r\n        this._activeEffect.setFloat(\"time\", this._lastTime / 100000);\r\n        this._activeEffect.setFloat(\"windForce\", this.windForce);\r\n        this._activeEffect.setFloat(\"waveHeight\", this.waveHeight);\r\n        this._activeEffect.setFloat(\"bumpHeight\", this.bumpHeight);\r\n        this._activeEffect.setColor4(\"waterColor\", this.waterColor, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor\", this.colorBlendFactor);\r\n        this._activeEffect.setColor4(\"waterColor2\", this.waterColor2, 1.0);\r\n        this._activeEffect.setFloat(\"colorBlendFactor2\", this.colorBlendFactor2);\r\n        this._activeEffect.setFloat(\"waveSpeed\", this.waveSpeed);\r\n        this._activeEffect.setFloat(\"waveCount\", this.waveCount);\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    private _createRenderTargets(scene: Scene, renderTargetSize: Vector2): void {\r\n        // Render targets\r\n        this._refractionRTT = new RenderTargetTexture(name + \"_refraction\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._refractionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._refractionRTT.ignoreCameraViewport = true;\r\n\r\n        this._reflectionRTT = new RenderTargetTexture(name + \"_reflection\", { width: renderTargetSize.x, height: renderTargetSize.y }, scene, false, true);\r\n        this._reflectionRTT.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._reflectionRTT.ignoreCameraViewport = true;\r\n\r\n        let isVisible: boolean;\r\n        let clipPlane: Nullable<Plane> = null;\r\n        let savedViewMatrix: Matrix;\r\n        const mirrorMatrix = Matrix.Zero();\r\n\r\n        this._refractionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony + 0.05, 0), new Vector3(0, 1, 0));\r\n            }\r\n        };\r\n\r\n        this._refractionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                scene.clipPlane = clipPlane;\r\n            }\r\n        };\r\n\r\n        this._reflectionRTT.onBeforeRender = () => {\r\n            if (this._mesh) {\r\n                isVisible = this._mesh.isVisible;\r\n                this._mesh.isVisible = false;\r\n            }\r\n\r\n            // Clip plane\r\n            if (!this.disableClipPlane) {\r\n                clipPlane = scene.clipPlane;\r\n\r\n                const positiony = this._mesh ? this._mesh.absolutePosition.y : 0.0;\r\n                scene.clipPlane = Plane.FromPositionAndNormal(new Vector3(0, positiony - 0.05, 0), new Vector3(0, -1, 0));\r\n\r\n                Matrix.ReflectionToRef(scene.clipPlane, mirrorMatrix);\r\n            }\r\n\r\n            // Transform\r\n            savedViewMatrix = scene.getViewMatrix();\r\n\r\n            mirrorMatrix.multiplyToRef(savedViewMatrix, this._reflectionTransform);\r\n            scene.setTransformMatrix(this._reflectionTransform, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = Vector3.TransformCoordinates((<Camera>scene.activeCamera).position, mirrorMatrix);\r\n        };\r\n\r\n        this._reflectionRTT.onAfterRender = () => {\r\n            if (this._mesh) {\r\n                this._mesh.isVisible = isVisible;\r\n            }\r\n\r\n            // Clip plane\r\n            scene.clipPlane = clipPlane;\r\n\r\n            // Transform\r\n            scene.setTransformMatrix(savedViewMatrix, scene.getProjectionMatrix());\r\n            scene._mirroredCameraPosition = null;\r\n        };\r\n    }\r\n\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = [];\r\n\r\n        if (this.bumpTexture && this.bumpTexture.animations && this.bumpTexture.animations.length > 0) {\r\n            results.push(this.bumpTexture);\r\n        }\r\n        if (this._reflectionRTT && this._reflectionRTT.animations && this._reflectionRTT.animations.length > 0) {\r\n            results.push(this._reflectionRTT);\r\n        }\r\n        if (this._refractionRTT && this._refractionRTT.animations && this._refractionRTT.animations.length > 0) {\r\n            results.push(this._refractionRTT);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean): void {\r\n        if (this.bumpTexture) {\r\n            this.bumpTexture.dispose();\r\n        }\r\n\r\n        let index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._refractionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n        index = -1;\r\n        index = this.getScene().customRenderTargets.indexOf(<RenderTargetTexture>this._reflectionRTT);\r\n        if (index != -1) {\r\n            this.getScene().customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        if (this._reflectionRTT) {\r\n            this._reflectionRTT.dispose();\r\n        }\r\n        if (this._refractionRTT) {\r\n            this._refractionRTT.dispose();\r\n        }\r\n\r\n        // Remove image-processing observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect);\r\n    }\r\n\r\n    public clone(name: string): WaterMaterial {\r\n        return SerializationHelper.Clone(() => new WaterMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.WaterMaterial\";\r\n\r\n        serializationObject.renderList = [];\r\n        if (this._refractionRTT && this._refractionRTT.renderList) {\r\n            for (let i = 0; i < this._refractionRTT.renderList.length; i++) {\r\n                serializationObject.renderList.push(this._refractionRTT.renderList[i].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"WaterMaterial\";\r\n    }\r\n\r\n    // Statics\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): WaterMaterial {\r\n        const mat = SerializationHelper.Parse(() => new WaterMaterial(source.name, scene), source, scene, rootUrl);\r\n        mat._waitingRenderList = source.renderList;\r\n\r\n        return mat;\r\n    }\r\n\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreateGround(name, { width: 512, height: 512, subdivisions: 32, updatable: false }, scene);\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.WaterMaterial\", WaterMaterial);\r\n","/* eslint-disable import/no-internal-modules */\nimport * as MatLib from \"../index\";\n/**\n * Legacy support, defining window.BABYLON.GridMaterial... (global variable).\n *\n * This is the entry point for the UMD module.\n * The entry point for a future ESM package should be index.ts\n */\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\nif (typeof globalObject !== \"undefined\") {\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\n    for (const mat in MatLib) {\n        (<any>globalObject).BABYLON[mat] = (<any>MatLib)[mat];\n    }\n}\nexport * from \"../index\";\n","import * as materials from \"materials/legacy/legacy\";\r\nexport { materials };\r\nexport default materials;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__520__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","extendStatics","b","setPrototypeOf","__proto__","Array","p","__extends","TypeError","String","__","constructor","create","__decorate","decorators","target","desc","c","arguments","length","getOwnPropertyDescriptor","Reflect","decorate","i","DIFFUSE","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","ALPHATEST","POINTSIZE","FOG","NORMAL","UV1","UV2","VERTEXCOLOR","VERTEXALPHA","NUM_BONE_INFLUENCERS","BonesPerMesh","INSTANCES","INSTANCESCOLOR","NDOTL","CUSTOMUSERLIGHTING","CELLBASIC","DEPTHPREPASS","IMAGEPROCESSINGPOSTPROCESS","SKIPFINALCOLORCLAMP","rebuild","MaterialDefines","name","scene","diffuseColor","Color3","_computeHighLevel","_disableLighting","_maxSimultaneousLights","needAlphaBlending","alpha","needAlphaTesting","getAlphaTestTexture","isReadyForSubMesh","mesh","subMesh","useInstances","isFrozen","effect","_wasPreviouslyReady","_wasPreviouslyUsingInstances","materialDefines","CellMaterialDefines","defines","getScene","_isReadyForSubMesh","engine","getEngine","_areTexturesDirty","_needUVs","texturesEnabled","_diffuseTexture","MaterialFlags","isReady","computeHighLevel","MaterialHelper","pointsCloud","fogEnabled","_shouldTurnAlphaTestOn","_needNormals","isDirty","markAsProcessed","resetCachedMaterial","fallbacks","EffectFallbacks","addFallback","maxSimultaneousLights","addCPUSkinningFallback","imageProcessingConfiguration","applyByPostProcess","attribs","VertexBuffer","push","join","toString","uniforms","samplers","uniformBuffers","addClipPlaneUniforms","uniformsNames","uniformBuffersNames","setEffect","createEffect","attributes","onCompiled","onError","indexParameters","_materialContext","_renderId","getRenderId","bindForSubMesh","world","_activeEffect","bindOnlyWorldMatrix","setMatrix","getTransformMatrix","_mustRebind","setTexture","setFloat2","coordinatesIndex","level","getTextureMatrix","bindClipPlane","setFloat","pointSize","bindEyePosition","setColor4","visibility","lightsEnabled","disableLighting","applyFog","fogMode","Scene","getViewMatrix","_afterBind","getAnimatables","results","animations","getActiveTextures","activeTextures","hasTexture","texture","dispose","forceDisposeEffect","getClassName","clone","SerializationHelper","CellMaterial","serialize","serializationObject","customType","Parse","source","rootUrl","serializeAsTexture","expandToProperty","serializeAsColor3","PushMaterial","RegisterClass","CustomParts","ShaderSpecialParts","customShaderNameResolve","Builder","FragmentShader","Effect","VertexShader","AttachAfterBind","_newUniformInstances","el","ea","split","setVector2","setVector3","setVector4","_newSamplerInstances","ReviewUniform","arr","_newUniforms","ind","_customUniform","indexOf","replace","shaderName","_customAttributes","_isCreatedShader","_createdShaderName","CustomMaterial","ShaderIndexer","fn_afterBind","bind","m","Vertex_Begin","Vertex_Definitions","Vertex_MainBegin","Vertex_Before_PositionUpdated","Vertex_Before_NormalUpdated","Vertex_MainEnd","Vertex_After_WorldPosComputed","Fragment_Begin","Fragment_MainBegin","Fragment_Definitions","Fragment_Custom_Diffuse","Fragment_Custom_Alpha","Fragment_Before_Lights","Fragment_Before_FragColor","Fragment_MainEnd","Fragment_Before_Fog","AddUniform","kind","param","AddAttribute","shaderPart","StandardMaterial","ShaderAlebdoParts","options","processFinalCode","type","code","sci","ShaderCodeInliner","inlineToken","processCode","PBRCustomMaterial","Fragment_Custom_Albedo","Fragment_Custom_MetallicRoughness","Fragment_Custom_MicroSurface","Fragment_Before_FinalColorComposition","PBRMaterial","ShaderStore","speed","_scaledDiffuse","_lastTime","FireMaterialDefines","_opacityTexture","_areMiscDirty","forcePointsCloud","transformFeedbackVaryings","_distortionTexture","getDeltaTime","FireMaterial","asArray","material","id","Tags","tags","backFaceCulling","wireframe","Texture","HEIGHTMAP","HIGHLEVEL","furLength","furAngle","furColor","furOffset","furSpacing","furGravity","Vector3","furSpeed","furDensity","furOcclusion","highLevelFur","_furTime","furTime","updateFur","_meshes","offsetFur","diffuseTexture","furTexture","FurMaterialDefines","heightTexture","getCaps","maxVertexTextureImageUnits","markAsUnprocessed","getCachedMaterial","_heightTexture","mat","FurMaterial","sourceMeshName","quality","executeWhenReady","sourceMesh","getMeshByName","GenerateTexture","FurifyMesh","DynamicTexture","context","getContext","fillStyle","Math","floor","random","fillRect","getSize","width","height","update","wrapU","wrapV","meshes","materials","pop","offsetMesh","skeleton","position","parent","serializeAsVector3","EMISSIVE","topColor","topColorAlpha","bottomColor","bottomColorAlpha","offset","scale","smoothness","GradientMaterialDefines","GradientMaterial","OPACITY","TRANSPARENT","PREMULTIPLYALPHA","MAX_LINE","THIN_INSTANCES","mainColor","lineColor","gridRatio","gridOffset","majorUnitFrequency","minorUnitVisibility","opacity","preMultiplyAlpha","useMaxLine","_gridControl","Vector4","needAlphaBlendingForMesh","GridMaterialDefines","THIN_INSTANCE","getProjectionMatrix","setColor3","x","y","round","z","w","GridMaterial","LIGHT0","LIGHT1","LIGHT2","LIGHT3","SPOTLIGHT0","SPOTLIGHT1","SPOTLIGHT2","SPOTLIGHT3","HEMILIGHT0","HEMILIGHT1","HEMILIGHT2","HEMILIGHT3","DIRLIGHT0","DIRLIGHT1","DIRLIGHT2","DIRLIGHT3","POINTLIGHT0","POINTLIGHT1","POINTLIGHT2","POINTLIGHT3","SHADOW0","SHADOW1","SHADOW2","SHADOW3","SHADOWS","SHADOWESM0","SHADOWESM1","SHADOWESM2","SHADOWESM3","SHADOWPOISSON0","SHADOWPOISSON1","SHADOWPOISSON2","SHADOWPOISSON3","SHADOWPCF0","SHADOWPCF1","SHADOWPCF2","SHADOWPCF3","SHADOWPCSS0","SHADOWPCSS1","SHADOWPCSS2","SHADOWPCSS3","UNLIT","movingSpeed","lowFrequencySpeed","fogDensity","_unlit","LavaMaterialDefines","noiseTexture","fogColor","LavaMaterial","SPECULARTERM","MIXMAP2","specularColor","specularPower","MixMaterialDefines","_mixTexture1","_diffuseTexture1","_diffuseTexture2","_diffuseTexture3","_diffuseTexture4","_mixTexture2","_diffuseTexture5","_diffuseTexture6","_diffuseTexture7","_diffuseTexture8","uScale","vScale","MixMaterial","LIGHTING","NormalMaterialDefines","NormalMaterial","_needAlphaBlending","shadowColor","_activeLight","light","_getFirstShadowLightForMesh","lightSources","shadowEnabled","ShadowOnlyMaterialDefines","lightPosition","splice","shadowGenerator","getShadowGenerator","csg","autoCalcDepthBounds","ShadowOnlyMaterial","SimpleMaterialDefines","SimpleMaterial","DITHER","luminance","turbidity","rayleigh","mieCoefficient","mieDirectionalG","distance","inclination","azimuth","sunPosition","useSunPosition","cameraOffset","up","dithering","_cameraPosition","_skyOrientation","Quaternion","SkyMaterialDefines","markAsMiscDirty","camera","activeCamera","cameraWorldMatrix","getWorldMatrix","theta","PI","phi","cos","sin","rotateByQuaternionToRef","SkyMaterial","BUMP","TerrainMaterialDefines","mixTexture","diffuseTexture1","diffuseTexture2","diffuseTexture3","bumpTexture1","bumpTexture2","bumpTexture3","_mixTexture","standardDerivatives","_bumpTexture1","_bumpTexture2","_bumpTexture3","TerrainMaterial","DIFFUSEX","DIFFUSEY","DIFFUSEZ","BUMPX","BUMPY","BUMPZ","tileSize","TriPlanarMaterialDefines","textures","diffuseTextureX","diffuseTextureY","diffuseTextureZ","textureDefines","normalTextureX","normalTextureY","normalTextureZ","_diffuseTextureX","_diffuseTextureY","_diffuseTextureZ","_normalTextureX","_normalTextureY","_normalTextureZ","TriPlanarMaterial","REFLECTION","LOGARITHMICDEPTH","USE_REVERSE_DEPTHBUFFER","FRESNELSEPARATE","BUMPSUPERIMPOSE","BUMPAFFECTSREFLECTION","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","TONEMAPPING_ACES","CONTRAST","EXPOSURE","COLORCURVES","COLORGRADING","COLORGRADING3D","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","renderTargetSize","Vector2","windForce","windDirection","waveHeight","bumpHeight","_bumpSuperimpose","_fresnelSeparate","_bumpAffectsReflection","waterColor","colorBlendFactor","waterColor2","colorBlendFactor2","waveLength","waveSpeed","waveCount","disableClipPlane","_renderTargets","SmartArray","_mesh","_reflectionTransform","Matrix","_lastDeltaTime","_createRenderTargets","getRenderTargetTextures","reset","_reflectionRTT","_refractionRTT","_imageProcessingConfiguration","_imageProcessingObserver","onUpdateParameters","add","_markAllSubMeshesAsImageProcessingDirty","_useLogarithmicDepth","fragmentDepthSupported","_markAllSubMeshesAsMiscDirty","addToRenderList","node","renderList","enableRenderTargets","enable","refreshRate","getRenderList","WaterMaterialDefines","bumpTexture","_areImageProcessingDirty","prepareDefines","IS_REFLECTION_LINEAR","reflectionTexture","gammaSpace","IS_REFRACTION_LINEAR","refractionTexture","_waitingRenderList","getNodeById","ImageProcessingConfiguration","wrvp","multiply","deltaTime","isVisible","RenderTargetTexture","Constants","ignoreCameraViewport","savedViewMatrix","clipPlane","mirrorMatrix","onBeforeRender","positiony","absolutePosition","Plane","onAfterRender","multiplyToRef","setTransformMatrix","_mirroredCameraPosition","_bumpTexture","index","customRenderTargets","remove","WaterMaterial","CreateDefaultMesh","CreateGround","subdivisions","updatable","serializeAsVector2","globalObject","BABYLON"],"sourceRoot":""}